## *****************************************************************************
##  Copyright (c) 2008-2020 The Khronos Group Inc.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##     http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
## ****************************************************************************

import
  std / [setutils],
  ./[version, platform],
  ./private/[climport]

## ***************************************************************************


type
  PlatformIdObj {.noDecl, incompleteStruct.} = object
  DeviceIdObj {.noDecl, incompleteStruct.} = object
  ContextObj {.noDecl, incompleteStruct.} = object
  CommandQueueObj {.noDecl, incompleteStruct.} = object
  MemObj {.noDecl, incompleteStruct.} = object
  ProgramObj {.noDecl, incompleteStruct.} = object
  KernelObj {.noDecl, incompleteStruct.} = object
  EventObj {.noDecl, incompleteStruct.} = object
  SamplerObj {.noDecl, incompleteStruct.} = object

type
  PlatformId* = ptr PlatformIdObj
  DeviceId* = ptr DeviceIdObj
  Context* = ptr ContextObj
  CommandQueue* = ptr CommandQueueObj
  Mem* = ptr MemObj
  Program* = ptr ProgramObj
  Kernel* = ptr KernelObj
  Event* = ptr EventObj
  Sampler* = ptr SamplerObj

type Bitfield* = Ulong

type intptr_t* {.importc.} = int

when ApiVersion >= opencl2_0:
  type PipeProperties* = intptr_t


# ***************************************************************************
#  Error Codes

when ApiVersion >= opencl2_2:
  type ErrorCode* {.size: sizeOf(Int), pure.} = enum
    # INVALID_GL_SHAREGROUP_REFERENCE = -1000
    MAX_SIZE_RESTRICTION_EXCEEDED = -72
    INVALID_SPEC_ID = -71
    INVALID_DEVICE_QUEUE = -70
    INVALID_PIPE_SIZE = -69
    INVALID_DEVICE_PARTITION_COUNT = -68
    INVALID_LINKER_OPTIONS = -67
    INVALID_COMPILER_OPTIONS = -66
    INVALID_IMAGE_DESCRIPTOR = -65
    INVALID_PROPERTY = -64
    INVALID_GLOBAL_WORK_SIZE = -63
    INVALID_MIP_LEVEL = -62
    INVALID_BUFFER_SIZE = -61
    INVALID_GL_OBJECT = -60
    INVALID_OPERATION = -59
    INVALID_EVENT = -58
    INVALID_EVENT_WAIT_LIST = -57
    INVALID_GLOBAL_OFFSET = -56
    INVALID_WORK_ITEM_SIZE = -55
    INVALID_WORK_GROUP_SIZE = -54
    INVALID_WORK_DIMENSION = -53
    INVALID_KERNEL_ARGS = -52
    INVALID_ARG_SIZE = -51
    INVALID_ARG_VALUE = -50
    INVALID_ARG_INDEX = -49
    INVALID_KERNEL = -48
    INVALID_KERNEL_DEFINITION = -47
    INVALID_KERNEL_NAME = -46
    INVALID_PROGRAM_EXECUTABLE = -45
    INVALID_PROGRAM = -44
    INVALID_BUILD_OPTIONS = -43
    INVALID_BINARY = -42
    INVALID_SAMPLER = -41
    INVALID_IMAGE_SIZE = -40
    INVALID_IMAGE_FORMAT_DESCRIPTOR = -39
    INVALID_MEM_OBJECT = -38
    INVALID_HOST_PTR = -37
    INVALID_COMMAND_QUEUE = -36
    INVALID_QUEUE_PROPERTIES = -35
    INVALID_CONTEXT = -34
    INVALID_DEVICE = -33
    INVALID_PLATFORM = -32
    INVALID_DEVICE_TYPE = -31
    INVALID_VALUE = -30
    KERNEL_ARG_INFO_NOT_AVAILABLE = -19
    DEVICE_PARTITION_FAILED = -18
    LINK_PROGRAM_FAILURE = -17
    LINKER_NOT_AVAILABLE = -16
    COMPILE_PROGRAM_FAILURE = -15
    EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = -14
    MISALIGNED_SUB_BUFFER_OFFSET = -13
    MAP_FAILURE = -12
    BUILD_PROGRAM_FAILURE = -11
    IMAGE_FORMAT_NOT_SUPPORTED = -10
    IMAGE_FORMAT_MISMATCH = -9
    MEM_COPY_OVERLAP = -8
    PROFILING_INFO_NOT_AVAILABLE = -7
    OUT_OF_HOST_MEMORY = -6
    OUT_OF_RESOURCES = -5
    MEM_OBJECT_ALLOCATION_FAILURE = -4
    COMPILER_NOT_AVAILABLE = -3
    DEVICE_NOT_AVAILABLE = -2
    DEVICE_NOT_FOUND = -1
    SUCCESS = 0

elif ApiVersion >= opencl2_0:
  type ErrorCode* {.size: sizeOf(Int), pure.} = enum
    # INVALID_GL_SHAREGROUP_REFERENCE = -1000
    INVALID_DEVICE_QUEUE = -70
    INVALID_PIPE_SIZE = -69
    INVALID_DEVICE_PARTITION_COUNT = -68
    INVALID_LINKER_OPTIONS = -67
    INVALID_COMPILER_OPTIONS = -66
    INVALID_IMAGE_DESCRIPTOR = -65
    INVALID_PROPERTY = -64
    INVALID_GLOBAL_WORK_SIZE = -63
    INVALID_MIP_LEVEL = -62
    INVALID_BUFFER_SIZE = -61
    INVALID_GL_OBJECT = -60
    INVALID_OPERATION = -59
    INVALID_EVENT = -58
    INVALID_EVENT_WAIT_LIST = -57
    INVALID_GLOBAL_OFFSET = -56
    INVALID_WORK_ITEM_SIZE = -55
    INVALID_WORK_GROUP_SIZE = -54
    INVALID_WORK_DIMENSION = -53
    INVALID_KERNEL_ARGS = -52
    INVALID_ARG_SIZE = -51
    INVALID_ARG_VALUE = -50
    INVALID_ARG_INDEX = -49
    INVALID_KERNEL = -48
    INVALID_KERNEL_DEFINITION = -47
    INVALID_KERNEL_NAME = -46
    INVALID_PROGRAM_EXECUTABLE = -45
    INVALID_PROGRAM = -44
    INVALID_BUILD_OPTIONS = -43
    INVALID_BINARY = -42
    INVALID_SAMPLER = -41
    INVALID_IMAGE_SIZE = -40
    INVALID_IMAGE_FORMAT_DESCRIPTOR = -39
    INVALID_MEM_OBJECT = -38
    INVALID_HOST_PTR = -37
    INVALID_COMMAND_QUEUE = -36
    INVALID_QUEUE_PROPERTIES = -35
    INVALID_CONTEXT = -34
    INVALID_DEVICE = -33
    INVALID_PLATFORM = -32
    INVALID_DEVICE_TYPE = -31
    INVALID_VALUE = -30
    KERNEL_ARG_INFO_NOT_AVAILABLE = -19
    DEVICE_PARTITION_FAILED = -18
    LINK_PROGRAM_FAILURE = -17
    LINKER_NOT_AVAILABLE = -16
    COMPILE_PROGRAM_FAILURE = -15
    EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = -14
    MISALIGNED_SUB_BUFFER_OFFSET = -13
    MAP_FAILURE = -12
    BUILD_PROGRAM_FAILURE = -11
    IMAGE_FORMAT_NOT_SUPPORTED = -10
    IMAGE_FORMAT_MISMATCH = -9
    MEM_COPY_OVERLAP = -8
    PROFILING_INFO_NOT_AVAILABLE = -7
    OUT_OF_HOST_MEMORY = -6
    OUT_OF_RESOURCES = -5
    MEM_OBJECT_ALLOCATION_FAILURE = -4
    COMPILER_NOT_AVAILABLE = -3
    DEVICE_NOT_AVAILABLE = -2
    DEVICE_NOT_FOUND = -1
    SUCCESS = 0

elif ApiVersion >= opencl1_2:
  type ErrorCode* {.size: sizeOf(Int), pure.} = enum
    # INVALID_GL_SHAREGROUP_REFERENCE = -1000
    INVALID_DEVICE_PARTITION_COUNT = -68
    INVALID_LINKER_OPTIONS = -67
    INVALID_COMPILER_OPTIONS = -66
    INVALID_IMAGE_DESCRIPTOR = -65
    INVALID_PROPERTY = -64
    INVALID_GLOBAL_WORK_SIZE = -63
    INVALID_MIP_LEVEL = -62
    INVALID_BUFFER_SIZE = -61
    INVALID_GL_OBJECT = -60
    INVALID_OPERATION = -59
    INVALID_EVENT = -58
    INVALID_EVENT_WAIT_LIST = -57
    INVALID_GLOBAL_OFFSET = -56
    INVALID_WORK_ITEM_SIZE = -55
    INVALID_WORK_GROUP_SIZE = -54
    INVALID_WORK_DIMENSION = -53
    INVALID_KERNEL_ARGS = -52
    INVALID_ARG_SIZE = -51
    INVALID_ARG_VALUE = -50
    INVALID_ARG_INDEX = -49
    INVALID_KERNEL = -48
    INVALID_KERNEL_DEFINITION = -47
    INVALID_KERNEL_NAME = -46
    INVALID_PROGRAM_EXECUTABLE = -45
    INVALID_PROGRAM = -44
    INVALID_BUILD_OPTIONS = -43
    INVALID_BINARY = -42
    INVALID_SAMPLER = -41
    INVALID_IMAGE_SIZE = -40
    INVALID_IMAGE_FORMAT_DESCRIPTOR = -39
    INVALID_MEM_OBJECT = -38
    INVALID_HOST_PTR = -37
    INVALID_COMMAND_QUEUE = -36
    INVALID_QUEUE_PROPERTIES = -35
    INVALID_CONTEXT = -34
    INVALID_DEVICE = -33
    INVALID_PLATFORM = -32
    INVALID_DEVICE_TYPE = -31
    INVALID_VALUE = -30
    KERNEL_ARG_INFO_NOT_AVAILABLE = -19
    DEVICE_PARTITION_FAILED = -18
    LINK_PROGRAM_FAILURE = -17
    LINKER_NOT_AVAILABLE = -16
    COMPILE_PROGRAM_FAILURE = -15
    EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = -14
    MISALIGNED_SUB_BUFFER_OFFSET = -13
    MAP_FAILURE = -12
    BUILD_PROGRAM_FAILURE = -11
    IMAGE_FORMAT_NOT_SUPPORTED = -10
    IMAGE_FORMAT_MISMATCH = -9
    MEM_COPY_OVERLAP = -8
    PROFILING_INFO_NOT_AVAILABLE = -7
    OUT_OF_HOST_MEMORY = -6
    OUT_OF_RESOURCES = -5
    MEM_OBJECT_ALLOCATION_FAILURE = -4
    COMPILER_NOT_AVAILABLE = -3
    DEVICE_NOT_AVAILABLE = -2
    DEVICE_NOT_FOUND = -1
    SUCCESS = 0

elif ApiVersion >= opencl1_1:
  type ErrorCode* {.size: sizeOf(Int), pure.} = enum
    # INVALID_GL_SHAREGROUP_REFERENCE = -1000
    INVALID_PROPERTY = -64
    INVALID_GLOBAL_WORK_SIZE = -63
    INVALID_MIP_LEVEL = -62
    INVALID_BUFFER_SIZE = -61
    INVALID_GL_OBJECT = -60
    INVALID_OPERATION = -59
    INVALID_EVENT = -58
    INVALID_EVENT_WAIT_LIST = -57
    INVALID_GLOBAL_OFFSET = -56
    INVALID_WORK_ITEM_SIZE = -55
    INVALID_WORK_GROUP_SIZE = -54
    INVALID_WORK_DIMENSION = -53
    INVALID_KERNEL_ARGS = -52
    INVALID_ARG_SIZE = -51
    INVALID_ARG_VALUE = -50
    INVALID_ARG_INDEX = -49
    INVALID_KERNEL = -48
    INVALID_KERNEL_DEFINITION = -47
    INVALID_KERNEL_NAME = -46
    INVALID_PROGRAM_EXECUTABLE = -45
    INVALID_PROGRAM = -44
    INVALID_BUILD_OPTIONS = -43
    INVALID_BINARY = -42
    INVALID_SAMPLER = -41
    INVALID_IMAGE_SIZE = -40
    INVALID_IMAGE_FORMAT_DESCRIPTOR = -39
    INVALID_MEM_OBJECT = -38
    INVALID_HOST_PTR = -37
    INVALID_COMMAND_QUEUE = -36
    INVALID_QUEUE_PROPERTIES = -35
    INVALID_CONTEXT = -34
    INVALID_DEVICE = -33
    INVALID_PLATFORM = -32
    INVALID_DEVICE_TYPE = -31
    INVALID_VALUE = -30
    EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = -14
    MISALIGNED_SUB_BUFFER_OFFSET = -13
    MAP_FAILURE = -12
    BUILD_PROGRAM_FAILURE = -11
    IMAGE_FORMAT_NOT_SUPPORTED = -10
    IMAGE_FORMAT_MISMATCH = -9
    MEM_COPY_OVERLAP = -8
    PROFILING_INFO_NOT_AVAILABLE = -7
    OUT_OF_HOST_MEMORY = -6
    OUT_OF_RESOURCES = -5
    MEM_OBJECT_ALLOCATION_FAILURE = -4
    COMPILER_NOT_AVAILABLE = -3
    DEVICE_NOT_AVAILABLE = -2
    DEVICE_NOT_FOUND = -1
    SUCCESS = 0

else:
  type ErrorCode* {.size: sizeOf(Int), pure.} = enum
    # INVALID_GL_SHAREGROUP_REFERENCE = -1000
    INVALID_GLOBAL_WORK_SIZE = -63
    INVALID_MIP_LEVEL = -62
    INVALID_BUFFER_SIZE = -61
    INVALID_GL_OBJECT = -60
    INVALID_OPERATION = -59
    INVALID_EVENT = -58
    INVALID_EVENT_WAIT_LIST = -57
    INVALID_GLOBAL_OFFSET = -56
    INVALID_WORK_ITEM_SIZE = -55
    INVALID_WORK_GROUP_SIZE = -54
    INVALID_WORK_DIMENSION = -53
    INVALID_KERNEL_ARGS = -52
    INVALID_ARG_SIZE = -51
    INVALID_ARG_VALUE = -50
    INVALID_ARG_INDEX = -49
    INVALID_KERNEL = -48
    INVALID_KERNEL_DEFINITION = -47
    INVALID_KERNEL_NAME = -46
    INVALID_PROGRAM_EXECUTABLE = -45
    INVALID_PROGRAM = -44
    INVALID_BUILD_OPTIONS = -43
    INVALID_BINARY = -42
    INVALID_SAMPLER = -41
    INVALID_IMAGE_SIZE = -40
    INVALID_IMAGE_FORMAT_DESCRIPTOR = -39
    INVALID_MEM_OBJECT = -38
    INVALID_HOST_PTR = -37
    INVALID_COMMAND_QUEUE = -36
    INVALID_QUEUE_PROPERTIES = -35
    INVALID_CONTEXT = -34
    INVALID_DEVICE = -33
    INVALID_PLATFORM = -32
    INVALID_DEVICE_TYPE = -31
    INVALID_VALUE = -30
    MAP_FAILURE = -12
    BUILD_PROGRAM_FAILURE = -11
    IMAGE_FORMAT_NOT_SUPPORTED = -10
    IMAGE_FORMAT_MISMATCH = -9
    MEM_COPY_OVERLAP = -8
    PROFILING_INFO_NOT_AVAILABLE = -7
    OUT_OF_HOST_MEMORY = -6
    OUT_OF_RESOURCES = -5
    MEM_OBJECT_ALLOCATION_FAILURE = -4
    COMPILER_NOT_AVAILABLE = -3
    DEVICE_NOT_AVAILABLE = -2
    DEVICE_NOT_FOUND = -1
    SUCCESS = 0


type Bool* {.size: sizeOf(Uint), pure.} = enum
  ##  WARNING!  Unlike the types in platform.nim, `Bool` is not guaranteed
  ## to be the same size as the bool in kernels.
  FALSE = 0
  TRUE = 1

when ApiVersion >= opencl1_2:
  const
    BLOCKING* = TRUE
    NON_BLOCKING* = FALSE

when ApiVersion >= opencl3_0 or ApiVersion >= opencl2_2:
  type PlatformInfo* {.size: sizeOf(Uint), pure.} = enum
    PROFILE = 0x0900
    VERSION = 0x0901
    NAME = 0x0902
    VENDOR = 0x0903
    EXTENSIONS = 0x0904
    HOST_TIMER_RESOLUTION = 0x0905
    PLATFORM_NUMERIC_VERSION = 0x0906
    PLATFORM_EXTENSIONS_WITH_VERSION = 0x0907

elif ApiVersion >= opencl2_1:
  type PlatformInfo* {.size: sizeOf(Uint), pure.} = enum
    PROFILE = 0x0900
    VERSION = 0x0901
    NAME = 0x0902
    VENDOR = 0x0903
    EXTENSIONS = 0x0904
    HOST_TIMER_RESOLUTION = 0x0905
else:
  type PlatformInfo* {.size: sizeOf(Uint), pure.} = enum
    PROFILE = 0x0900
    VERSION = 0x0901
    NAME = 0x0902
    VENDOR = 0x0903
    EXTENSIONS = 0x0904



#  cl_device_type - bitfield
# had to leave off the all option as the nim compiler complained about it being
# too big...
# so just use `std/setutils.fullset`instead.
when ApiVersion >= opencl1_2:
  type DeviceType* {.size: sizeOf(Bitfield), pure.} = enum
    DEFAULT = (1 shl 0)
    CPU = (1 shl 1)
    GPU = (1 shl 2)
    ACCELERATOR = (1 shl 3)
    CUSTOM = (1 shl 4)
  const DeviceTypeAll* = DeviceType.fullset
else:
  type DeviceType* {.size: sizeOf(Bitfield), pure.} = enum
    DEFAULT = 1
    CPU
    GPU
    ACCELERATOR
  const DeviceTypeAll* = DeviceType.fullset






#  cl_device_info
when ApiVersion >= opencl3_0:
  type DeviceInfo* {.size: sizeOf(Uint), pure.} = enum
    INFO_TYPE = 0x1000
    VENDOR_ID = 0x1001
    MAX_COMPUTE_UNITS = 0x1002
    MAX_WORK_ITEM_DIMENSIONS = 0x1003
    MAX_WORK_GROUP_SIZE = 0x1004
    MAX_WORK_ITEM_SIZES = 0x1005
    PREFERRED_VECTOR_WIDTH_CHAR = 0x1006
    PREFERRED_VECTOR_WIDTH_SHORT = 0x1007
    PREFERRED_VECTOR_WIDTH_INT = 0x1008
    PREFERRED_VECTOR_WIDTH_LONG = 0x1009
    PREFERRED_VECTOR_WIDTH_FLOAT = 0x100A
    PREFERRED_VECTOR_WIDTH_DOUBLE = 0x100B
    MAX_CLOCK_FREQUENCY = 0x100C
    ADDRESS_BITS = 0x100D
    MAX_READ_IMAGE_ARGS = 0x100E
    MAX_WRITE_IMAGE_ARGS = 0x100F
    MAX_MEM_ALLOC_SIZE = 0x1010
    IMAGE2D_MAX_WIDTH = 0x1011
    IMAGE2D_MAX_HEIGHT = 0x1012
    IMAGE3D_MAX_WIDTH = 0x1013
    IMAGE3D_MAX_HEIGHT = 0x1014
    IMAGE3D_MAX_DEPTH = 0x1015
    IMAGE_SUPPORT = 0x1016
    MAX_PARAMETER_SIZE = 0x1017
    MAX_SAMPLERS = 0x1018
    MEM_BASE_ADDR_ALIGN = 0x1019
    MIN_DATA_TYPE_ALIGN_SIZE = 0x101A
    SINGLE_FP_CONFIG = 0x101B
    GLOBAL_MEM_CACHE_TYPE = 0x101C
    GLOBAL_MEM_CACHELINE_SIZE = 0x101D
    GLOBAL_MEM_CACHE_SIZE = 0x101E
    GLOBAL_MEM_SIZE = 0x101F
    MAX_CONSTANT_BUFFER_SIZE = 0x1020
    MAX_CONSTANT_ARGS = 0x1021
    LOCAL_MEM_TYPE = 0x1022
    LOCAL_MEM_SIZE = 0x1023
    ERROR_CORRECTION_SUPPORT = 0x1024
    PROFILING_TIMER_RESOLUTION = 0x1025
    ENDIAN_LITTLE = 0x1026
    AVAILABLE = 0x1027
    COMPILER_AVAILABLE = 0x1028
    EXECUTION_CAPABILITIES = 0x1029
    # QUEUE_PROPERTIES = 0x102A
    QUEUE_ON_HOST_PROPERTIES = 0x102A
    NAME = 0x102B
    VENDOR = 0x102C
    DRIVER_VERSION = 0x102D
    PROFILE = 0x102E
    VERSION = 0x102F
    EXTENSIONS = 0x1030
    PLATFORM = 0x1031
    DOUBLE_FP_CONFIG = 0x1032
    #  0x1033 reserved for CL_DEVICE_HALF_FP_CONFIG which is already defined in "cl_ext.h"
    PREFERRED_VECTOR_WIDTH_HALF = 0x1034
    HOST_UNIFIED_MEMORY = 0x1035
    NATIVE_VECTOR_WIDTH_CHAR = 0x1036
    NATIVE_VECTOR_WIDTH_SHORT = 0x1037
    NATIVE_VECTOR_WIDTH_INT = 0x1038
    NATIVE_VECTOR_WIDTH_LONG = 0x1039
    NATIVE_VECTOR_WIDTH_FLOAT = 0x103A
    NATIVE_VECTOR_WIDTH_DOUBLE = 0x103B
    NATIVE_VECTOR_WIDTH_HALF = 0x103C
    OPENCL_C_VERSION = 0x103D
    LINKER_AVAILABLE = 0x103E
    BUILT_IN_KERNELS = 0x103F
    IMAGE_MAX_BUFFER_SIZE = 0x1040
    IMAGE_MAX_ARRAY_SIZE = 0x1041
    PARENT_DEVICE = 0x1042
    PARTITION_MAX_SUB_DEVICES = 0x1043
    PARTITION_PROPERTIES = 0x1044
    PARTITION_AFFINITY_DOMAIN = 0x1045
    PARTITION_TYPE = 0x1046
    REFERENCE_COUNT = 0x1047
    PREFERRED_INTEROP_USER_SYNC = 0x1048
    PRINTF_BUFFER_SIZE = 0x1049
    IMAGE_PITCH_ALIGNMENT = 0x104A
    IMAGE_BASE_ADDRESS_ALIGNMENT = 0x104B
    MAX_READ_WRITE_IMAGE_ARGS = 0x104C
    MAX_GLOBAL_VARIABLE_SIZE = 0x104D
    QUEUE_ON_PROPERTIES = 0x104E
    QUEUE_ON_PREFERRED_SIZE = 0x104F
    QUEUE_ON_MAX_SIZE = 0x1050
    MAX_ON_QUEUES = 0x1051
    MAX_ON_EVENTS = 0x1052
    SVM_CAPABILITIES = 0x1053
    GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE = 0x1054
    MAX_PIPE_ARGS = 0x1055
    PIPE_MAX_ACTIVE_RESERVATIONS = 0x1056
    PIPE_MAX_PACKET_SIZE = 0x1057
    PREFERRED_PLATFORM_ATOMIC_ALIGNMENT = 0x1058
    PREFERRED_GLOBAL_ATOMIC_ALIGNMENT = 0x1059
    PREFERRED_LOCAL_ATOMIC_ALIGNMENT = 0x105A
    IL_VERSION = 0x105B
    MAX_NUM_SUB_GROUPS = 0x105C
    SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS = 0x105D
    NUMERIC_VERSION = 0x105E
    EXTENSIONS_WITH_VERSION = 0x1060
    ILS_WITH_VERSION = 0x1061
    BUILT_IN_KERNELS_WITH_VERSION = 0x1062
    ATOMIC_MEMORY_CAPABILITIES = 0x1063
    ATOMIC_FENCE_CAPABILITIES = 0x1064
    NON_UNIFORM_WORK_GROUP_SUPPORT = 0x1065
    OPENCL_C_ALL_VERSIONS = 0x1066
    PREFERRED_WORK_GROUP_SIZE_MULTIPLE = 0x1067
    WORK_GROUP_COLLECTIVE_FUNCTIONS_SUPPORT = 0x1068
    GENERIC_ADDRESS_SPACE_SUPPORT = 0x1069
    #  0x106A to 0x106E - Reserved for upcoming KHR extension
    OPENCL_C_FEATURES = 0x106F
    DEVICE_ENQUEUE_CAPABILITIES = 0x1070
    PIPE_SUPPORT = 0x1071
    LATEST_CONFORMANCE_VERSION_PASSED = 0x1072

elif ApiVersion >= opencl2_2 or ApiVersion >= opencl2_1:
  type DeviceInfo* {.size: sizeOf(Uint), pure.} = enum
    INFO_TYPE = 0x1000
    VENDOR_ID = 0x1001
    MAX_COMPUTE_UNITS = 0x1002
    MAX_WORK_ITEM_DIMENSIONS = 0x1003
    MAX_WORK_GROUP_SIZE = 0x1004
    MAX_WORK_ITEM_SIZES = 0x1005
    PREFERRED_VECTOR_WIDTH_CHAR = 0x1006
    PREFERRED_VECTOR_WIDTH_SHORT = 0x1007
    PREFERRED_VECTOR_WIDTH_INT = 0x1008
    PREFERRED_VECTOR_WIDTH_LONG = 0x1009
    PREFERRED_VECTOR_WIDTH_FLOAT = 0x100A
    PREFERRED_VECTOR_WIDTH_DOUBLE = 0x100B
    MAX_CLOCK_FREQUENCY = 0x100C
    ADDRESS_BITS = 0x100D
    MAX_READ_IMAGE_ARGS = 0x100E
    MAX_WRITE_IMAGE_ARGS = 0x100F
    MAX_MEM_ALLOC_SIZE = 0x1010
    IMAGE2D_MAX_WIDTH = 0x1011
    IMAGE2D_MAX_HEIGHT = 0x1012
    IMAGE3D_MAX_WIDTH = 0x1013
    IMAGE3D_MAX_HEIGHT = 0x1014
    IMAGE3D_MAX_DEPTH = 0x1015
    IMAGE_SUPPORT = 0x1016
    MAX_PARAMETER_SIZE = 0x1017
    MAX_SAMPLERS = 0x1018
    MEM_BASE_ADDR_ALIGN = 0x1019
    MIN_DATA_TYPE_ALIGN_SIZE = 0x101A
    SINGLE_FP_CONFIG = 0x101B
    GLOBAL_MEM_CACHE_TYPE = 0x101C
    GLOBAL_MEM_CACHELINE_SIZE = 0x101D
    GLOBAL_MEM_CACHE_SIZE = 0x101E
    GLOBAL_MEM_SIZE = 0x101F
    MAX_CONSTANT_BUFFER_SIZE = 0x1020
    MAX_CONSTANT_ARGS = 0x1021
    LOCAL_MEM_TYPE = 0x1022
    LOCAL_MEM_SIZE = 0x1023
    ERROR_CORRECTION_SUPPORT = 0x1024
    PROFILING_TIMER_RESOLUTION = 0x1025
    ENDIAN_LITTLE = 0x1026
    AVAILABLE = 0x1027
    COMPILER_AVAILABLE = 0x1028
    EXECUTION_CAPABILITIES = 0x1029
    # QUEUE_PROPERTIES = 0x102A deprecated
    QUEUE_ON_HOST_PROPERTIES = 0x102A
    NAME = 0x102B
    VENDOR = 0x102C
    DRIVER_VERSION = 0x102D
    PROFILE = 0x102E
    VERSION = 0x102F
    EXTENSIONS = 0x1030
    PLATFORM = 0x1031
    DOUBLE_FP_CONFIG = 0x1032
    #  0x1033 reserved for CL_DEVICE_HALF_FP_CONFIG which is already defined in "cl_ext.h"
    PREFERRED_VECTOR_WIDTH_HALF = 0x1034
    HOST_UNIFIED_MEMORY = 0x1035
    NATIVE_VECTOR_WIDTH_CHAR = 0x1036
    NATIVE_VECTOR_WIDTH_SHORT = 0x1037
    NATIVE_VECTOR_WIDTH_INT = 0x1038
    NATIVE_VECTOR_WIDTH_LONG = 0x1039
    NATIVE_VECTOR_WIDTH_FLOAT = 0x103A
    NATIVE_VECTOR_WIDTH_DOUBLE = 0x103B
    NATIVE_VECTOR_WIDTH_HALF = 0x103C
    OPENCL_C_VERSION = 0x103D
    LINKER_AVAILABLE = 0x103E
    BUILT_IN_KERNELS = 0x103F
    IMAGE_MAX_BUFFER_SIZE = 0x1040
    IMAGE_MAX_ARRAY_SIZE = 0x1041
    PARENT_DEVICE = 0x1042
    PARTITION_MAX_SUB_DEVICES = 0x1043
    PARTITION_PROPERTIES = 0x1044
    PARTITION_AFFINITY_DOMAIN = 0x1045
    PARTITION_TYPE = 0x1046
    REFERENCE_COUNT = 0x1047
    PREFERRED_INTEROP_USER_SYNC = 0x1048
    PRINTF_BUFFER_SIZE = 0x1049
    IMAGE_PITCH_ALIGNMENT = 0x104A
    IMAGE_BASE_ADDRESS_ALIGNMENT = 0x104B
    MAX_READ_WRITE_IMAGE_ARGS = 0x104C
    MAX_GLOBAL_VARIABLE_SIZE = 0x104D
    QUEUE_ON_PROPERTIES = 0x104E
    QUEUE_ON_PREFERRED_SIZE = 0x104F
    QUEUE_ON_MAX_SIZE = 0x1050
    MAX_ON_QUEUES = 0x1051
    MAX_ON_EVENTS = 0x1052
    SVM_CAPABILITIES = 0x1053
    GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE = 0x1054
    MAX_PIPE_ARGS = 0x1055
    PIPE_MAX_ACTIVE_RESERVATIONS = 0x1056
    PIPE_MAX_PACKET_SIZE = 0x1057
    PREFERRED_PLATFORM_ATOMIC_ALIGNMENT = 0x1058
    PREFERRED_GLOBAL_ATOMIC_ALIGNMENT = 0x1059
    PREFERRED_LOCAL_ATOMIC_ALIGNMENT = 0x105A
    IL_VERSION = 0x105B
    MAX_NUM_SUB_GROUPS = 0x105C
    SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS = 0x105D

elif ApiVersion >= opencl2_0:
  type DeviceInfo* {.size: sizeOf(Uint), pure.} = enum
    INFO_TYPE = 0x1000
    VENDOR_ID = 0x1001
    MAX_COMPUTE_UNITS = 0x1002
    MAX_WORK_ITEM_DIMENSIONS = 0x1003
    MAX_WORK_GROUP_SIZE = 0x1004
    MAX_WORK_ITEM_SIZES = 0x1005
    PREFERRED_VECTOR_WIDTH_CHAR = 0x1006
    PREFERRED_VECTOR_WIDTH_SHORT = 0x1007
    PREFERRED_VECTOR_WIDTH_INT = 0x1008
    PREFERRED_VECTOR_WIDTH_LONG = 0x1009
    PREFERRED_VECTOR_WIDTH_FLOAT = 0x100A
    PREFERRED_VECTOR_WIDTH_DOUBLE = 0x100B
    MAX_CLOCK_FREQUENCY = 0x100C
    ADDRESS_BITS = 0x100D
    MAX_READ_IMAGE_ARGS = 0x100E
    MAX_WRITE_IMAGE_ARGS = 0x100F
    MAX_MEM_ALLOC_SIZE = 0x1010
    IMAGE2D_MAX_WIDTH = 0x1011
    IMAGE2D_MAX_HEIGHT = 0x1012
    IMAGE3D_MAX_WIDTH = 0x1013
    IMAGE3D_MAX_HEIGHT = 0x1014
    IMAGE3D_MAX_DEPTH = 0x1015
    IMAGE_SUPPORT = 0x1016
    MAX_PARAMETER_SIZE = 0x1017
    MAX_SAMPLERS = 0x1018
    MEM_BASE_ADDR_ALIGN = 0x1019
    MIN_DATA_TYPE_ALIGN_SIZE = 0x101A
    SINGLE_FP_CONFIG = 0x101B
    GLOBAL_MEM_CACHE_TYPE = 0x101C
    GLOBAL_MEM_CACHELINE_SIZE = 0x101D
    GLOBAL_MEM_CACHE_SIZE = 0x101E
    GLOBAL_MEM_SIZE = 0x101F
    MAX_CONSTANT_BUFFER_SIZE = 0x1020
    MAX_CONSTANT_ARGS = 0x1021
    LOCAL_MEM_TYPE = 0x1022
    LOCAL_MEM_SIZE = 0x1023
    ERROR_CORRECTION_SUPPORT = 0x1024
    PROFILING_TIMER_RESOLUTION = 0x1025
    ENDIAN_LITTLE = 0x1026
    AVAILABLE = 0x1027
    COMPILER_AVAILABLE = 0x1028
    EXECUTION_CAPABILITIES = 0x1029
    # QUEUE_PROPERTIES = 0x102A deprecated
    QUEUE_ON_HOST_PROPERTIES = 0x102A
    NAME = 0x102B
    VENDOR = 0x102C
    DRIVER_VERSION = 0x102D
    PROFILE = 0x102E
    VERSION = 0x102F
    EXTENSIONS = 0x1030
    PLATFORM = 0x1031
    DOUBLE_FP_CONFIG = 0x1032
    #  0x1033 reserved for CL_DEVICE_HALF_FP_CONFIG which is already defined in "cl_ext.h"
    PREFERRED_VECTOR_WIDTH_HALF = 0x1034
    HOST_UNIFIED_MEMORY = 0x1035
    NATIVE_VECTOR_WIDTH_CHAR = 0x1036
    NATIVE_VECTOR_WIDTH_SHORT = 0x1037
    NATIVE_VECTOR_WIDTH_INT = 0x1038
    NATIVE_VECTOR_WIDTH_LONG = 0x1039
    NATIVE_VECTOR_WIDTH_FLOAT = 0x103A
    NATIVE_VECTOR_WIDTH_DOUBLE = 0x103B
    NATIVE_VECTOR_WIDTH_HALF = 0x103C
    OPENCL_C_VERSION = 0x103D
    LINKER_AVAILABLE = 0x103E
    BUILT_IN_KERNELS = 0x103F
    IMAGE_MAX_BUFFER_SIZE = 0x1040
    IMAGE_MAX_ARRAY_SIZE = 0x1041
    PARENT_DEVICE = 0x1042
    PARTITION_MAX_SUB_DEVICES = 0x1043
    PARTITION_PROPERTIES = 0x1044
    PARTITION_AFFINITY_DOMAIN = 0x1045
    PARTITION_TYPE = 0x1046
    REFERENCE_COUNT = 0x1047
    PREFERRED_INTEROP_USER_SYNC = 0x1048
    PRINTF_BUFFER_SIZE = 0x1049
    IMAGE_PITCH_ALIGNMENT = 0x104A
    IMAGE_BASE_ADDRESS_ALIGNMENT = 0x104B
    MAX_READ_WRITE_IMAGE_ARGS = 0x104C
    MAX_GLOBAL_VARIABLE_SIZE = 0x104D
    QUEUE_ON_PROPERTIES = 0x104E
    QUEUE_ON_PREFERRED_SIZE = 0x104F
    QUEUE_ON_MAX_SIZE = 0x1050
    MAX_ON_QUEUES = 0x1051
    MAX_ON_EVENTS = 0x1052
    SVM_CAPABILITIES = 0x1053
    GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE = 0x1054
    MAX_PIPE_ARGS = 0x1055
    PIPE_MAX_ACTIVE_RESERVATIONS = 0x1056
    PIPE_MAX_PACKET_SIZE = 0x1057
    PREFERRED_PLATFORM_ATOMIC_ALIGNMENT = 0x1058
    PREFERRED_GLOBAL_ATOMIC_ALIGNMENT = 0x1059
    PREFERRED_LOCAL_ATOMIC_ALIGNMENT = 0x105A

elif ApiVersion >= opencl1_2:
  type DeviceInfo* {.size: sizeOf(Uint), pure.} = enum
    INFO_TYPE = 0x1000
    VENDOR_ID = 0x1001
    MAX_COMPUTE_UNITS = 0x1002
    MAX_WORK_ITEM_DIMENSIONS = 0x1003
    MAX_WORK_GROUP_SIZE = 0x1004
    MAX_WORK_ITEM_SIZES = 0x1005
    PREFERRED_VECTOR_WIDTH_CHAR = 0x1006
    PREFERRED_VECTOR_WIDTH_SHORT = 0x1007
    PREFERRED_VECTOR_WIDTH_INT = 0x1008
    PREFERRED_VECTOR_WIDTH_LONG = 0x1009
    PREFERRED_VECTOR_WIDTH_FLOAT = 0x100A
    PREFERRED_VECTOR_WIDTH_DOUBLE = 0x100B
    MAX_CLOCK_FREQUENCY = 0x100C
    ADDRESS_BITS = 0x100D
    MAX_READ_IMAGE_ARGS = 0x100E
    MAX_WRITE_IMAGE_ARGS = 0x100F
    MAX_MEM_ALLOC_SIZE = 0x1010
    IMAGE2D_MAX_WIDTH = 0x1011
    IMAGE2D_MAX_HEIGHT = 0x1012
    IMAGE3D_MAX_WIDTH = 0x1013
    IMAGE3D_MAX_HEIGHT = 0x1014
    IMAGE3D_MAX_DEPTH = 0x1015
    IMAGE_SUPPORT = 0x1016
    MAX_PARAMETER_SIZE = 0x1017
    MAX_SAMPLERS = 0x1018
    MEM_BASE_ADDR_ALIGN = 0x1019
    MIN_DATA_TYPE_ALIGN_SIZE = 0x101A
    SINGLE_FP_CONFIG = 0x101B
    GLOBAL_MEM_CACHE_TYPE = 0x101C
    GLOBAL_MEM_CACHELINE_SIZE = 0x101D
    GLOBAL_MEM_CACHE_SIZE = 0x101E
    GLOBAL_MEM_SIZE = 0x101F
    MAX_CONSTANT_BUFFER_SIZE = 0x1020
    MAX_CONSTANT_ARGS = 0x1021
    LOCAL_MEM_TYPE = 0x1022
    LOCAL_MEM_SIZE = 0x1023
    ERROR_CORRECTION_SUPPORT = 0x1024
    PROFILING_TIMER_RESOLUTION = 0x1025
    ENDIAN_LITTLE = 0x1026
    AVAILABLE = 0x1027
    COMPILER_AVAILABLE = 0x1028
    EXECUTION_CAPABILITIES = 0x1029
    QUEUE_PROPERTIES = 0x102A
    NAME = 0x102B
    VENDOR = 0x102C
    DRIVER_VERSION = 0x102D
    PROFILE = 0x102E
    VERSION = 0x102F
    EXTENSIONS = 0x1030
    PLATFORM = 0x1031
    DOUBLE_FP_CONFIG = 0x1032
    #  0x1033 reserved for CL_DEVICE_HALF_FP_CONFIG which is already defined in "cl_ext.h"
    PREFERRED_VECTOR_WIDTH_HALF = 0x1034
    HOST_UNIFIED_MEMORY = 0x1035
    NATIVE_VECTOR_WIDTH_CHAR = 0x1036
    NATIVE_VECTOR_WIDTH_SHORT = 0x1037
    NATIVE_VECTOR_WIDTH_INT = 0x1038
    NATIVE_VECTOR_WIDTH_LONG = 0x1039
    NATIVE_VECTOR_WIDTH_FLOAT = 0x103A
    NATIVE_VECTOR_WIDTH_DOUBLE = 0x103B
    NATIVE_VECTOR_WIDTH_HALF = 0x103C
    OPENCL_C_VERSION = 0x103D
    LINKER_AVAILABLE = 0x103E
    BUILT_IN_KERNELS = 0x103F
    IMAGE_MAX_BUFFER_SIZE = 0x1040
    IMAGE_MAX_ARRAY_SIZE = 0x1041
    PARENT_DEVICE = 0x1042
    PARTITION_MAX_SUB_DEVICES = 0x1043
    PARTITION_PROPERTIES = 0x1044
    PARTITION_AFFINITY_DOMAIN = 0x1045
    PARTITION_TYPE = 0x1046
    REFERENCE_COUNT = 0x1047
    PREFERRED_INTEROP_USER_SYNC = 0x1048
    PRINTF_BUFFER_SIZE = 0x1049

elif ApiVersion >= opencl1_1:
  type DeviceInfo* {.size: sizeOf(Uint), pure.} = enum
    INFO_TYPE = 0x1000
    VENDOR_ID = 0x1001
    MAX_COMPUTE_UNITS = 0x1002
    MAX_WORK_ITEM_DIMENSIONS = 0x1003
    MAX_WORK_GROUP_SIZE = 0x1004
    MAX_WORK_ITEM_SIZES = 0x1005
    PREFERRED_VECTOR_WIDTH_CHAR = 0x1006
    PREFERRED_VECTOR_WIDTH_SHORT = 0x1007
    PREFERRED_VECTOR_WIDTH_INT = 0x1008
    PREFERRED_VECTOR_WIDTH_LONG = 0x1009
    PREFERRED_VECTOR_WIDTH_FLOAT = 0x100A
    PREFERRED_VECTOR_WIDTH_DOUBLE = 0x100B
    MAX_CLOCK_FREQUENCY = 0x100C
    ADDRESS_BITS = 0x100D
    MAX_READ_IMAGE_ARGS = 0x100E
    MAX_WRITE_IMAGE_ARGS = 0x100F
    MAX_MEM_ALLOC_SIZE = 0x1010
    IMAGE2D_MAX_WIDTH = 0x1011
    IMAGE2D_MAX_HEIGHT = 0x1012
    IMAGE3D_MAX_WIDTH = 0x1013
    IMAGE3D_MAX_HEIGHT = 0x1014
    IMAGE3D_MAX_DEPTH = 0x1015
    IMAGE_SUPPORT = 0x1016
    MAX_PARAMETER_SIZE = 0x1017
    MAX_SAMPLERS = 0x1018
    MEM_BASE_ADDR_ALIGN = 0x1019
    MIN_DATA_TYPE_ALIGN_SIZE = 0x101A
    SINGLE_FP_CONFIG = 0x101B
    GLOBAL_MEM_CACHE_TYPE = 0x101C
    GLOBAL_MEM_CACHELINE_SIZE = 0x101D
    GLOBAL_MEM_CACHE_SIZE = 0x101E
    GLOBAL_MEM_SIZE = 0x101F
    MAX_CONSTANT_BUFFER_SIZE = 0x1020
    MAX_CONSTANT_ARGS = 0x1021
    LOCAL_MEM_TYPE = 0x1022
    LOCAL_MEM_SIZE = 0x1023
    ERROR_CORRECTION_SUPPORT = 0x1024
    PROFILING_TIMER_RESOLUTION = 0x1025
    ENDIAN_LITTLE = 0x1026
    AVAILABLE = 0x1027
    COMPILER_AVAILABLE = 0x1028
    EXECUTION_CAPABILITIES = 0x1029
    QUEUE_PROPERTIES = 0x102A
    NAME = 0x102B
    VENDOR = 0x102C
    DRIVER_VERSION = 0x102D
    PROFILE = 0x102E
    VERSION = 0x102F
    EXTENSIONS = 0x1030
    PLATFORM = 0x1031
    PREFERRED_VECTOR_WIDTH_HALF = 0x1034
    HOST_UNIFIED_MEMORY = 0x1035
    NATIVE_VECTOR_WIDTH_CHAR = 0x1036
    NATIVE_VECTOR_WIDTH_SHORT = 0x1037
    NATIVE_VECTOR_WIDTH_INT = 0x1038
    NATIVE_VECTOR_WIDTH_LONG = 0x1039
    NATIVE_VECTOR_WIDTH_FLOAT = 0x103A
    NATIVE_VECTOR_WIDTH_DOUBLE = 0x103B
    NATIVE_VECTOR_WIDTH_HALF = 0x103C
    OPENCL_C_VERSION = 0x103D

else:
  type DeviceInfo* {.size: sizeOf(Uint), pure.} = enum
    INFO_TYPE = 0x1000
    VENDOR_ID = 0x1001
    MAX_COMPUTE_UNITS = 0x1002
    MAX_WORK_ITEM_DIMENSIONS = 0x1003
    MAX_WORK_GROUP_SIZE = 0x1004
    MAX_WORK_ITEM_SIZES = 0x1005
    PREFERRED_VECTOR_WIDTH_CHAR = 0x1006
    PREFERRED_VECTOR_WIDTH_SHORT = 0x1007
    PREFERRED_VECTOR_WIDTH_INT = 0x1008
    PREFERRED_VECTOR_WIDTH_LONG = 0x1009
    PREFERRED_VECTOR_WIDTH_FLOAT = 0x100A
    PREFERRED_VECTOR_WIDTH_DOUBLE = 0x100B
    MAX_CLOCK_FREQUENCY = 0x100C
    ADDRESS_BITS = 0x100D
    MAX_READ_IMAGE_ARGS = 0x100E
    MAX_WRITE_IMAGE_ARGS = 0x100F
    MAX_MEM_ALLOC_SIZE = 0x1010
    IMAGE2D_MAX_WIDTH = 0x1011
    IMAGE2D_MAX_HEIGHT = 0x1012
    IMAGE3D_MAX_WIDTH = 0x1013
    IMAGE3D_MAX_HEIGHT = 0x1014
    IMAGE3D_MAX_DEPTH = 0x1015
    IMAGE_SUPPORT = 0x1016
    MAX_PARAMETER_SIZE = 0x1017
    MAX_SAMPLERS = 0x1018
    MEM_BASE_ADDR_ALIGN = 0x1019
    MIN_DATA_TYPE_ALIGN_SIZE = 0x101A
    SINGLE_FP_CONFIG = 0x101B
    GLOBAL_MEM_CACHE_TYPE = 0x101C
    GLOBAL_MEM_CACHELINE_SIZE = 0x101D
    GLOBAL_MEM_CACHE_SIZE = 0x101E
    GLOBAL_MEM_SIZE = 0x101F
    MAX_CONSTANT_BUFFER_SIZE = 0x1020
    MAX_CONSTANT_ARGS = 0x1021
    LOCAL_MEM_TYPE = 0x1022
    LOCAL_MEM_SIZE = 0x1023
    ERROR_CORRECTION_SUPPORT = 0x1024
    PROFILING_TIMER_RESOLUTION = 0x1025
    ENDIAN_LITTLE = 0x1026
    AVAILABLE = 0x1027
    COMPILER_AVAILABLE = 0x1028
    EXECUTION_CAPABILITIES = 0x1029
    QUEUE_PROPERTIES = 0x102A
    NAME = 0x102B
    VENDOR = 0x102C
    DRIVER_VERSION = 0x102D
    PROFILE = 0x102E
    VERSION = 0x102F
    EXTENSIONS = 0x1030
    PLATFORM = 0x1031


when ApiVersion >= opencl1_2:
  type DeviceFpConfig* {.size: sizeOf(Bitfield), pure.} = enum
    DENORM = (1 shl 0)
    INF_NAN = (1 shl 1)
    ROUND_TO_NEAREST = (1 shl 2)
    ROUND_TO_ZERO = (1 shl 3)
    ROUND_TO_INF = (1 shl 4)
    FMA = (1 shl 5)
    SOFT_FLOAT = (1 shl 6)
    CORRECTLY_ROUNDED_DIVIDE_SQRT = (1 shl 7)
elif ApiVersion >= opencl1_1:
  type DeviceFpConfig* {.size: sizeOf(Bitfield), pure.} = enum
    DENORM = (1 shl 0)
    INF_NAN = (1 shl 1)
    ROUND_TO_NEAREST = (1 shl 2)
    ROUND_TO_ZERO = (1 shl 3)
    ROUND_TO_INF = (1 shl 4)
    FMA = (1 shl 5)
    SOFT_FLOAT = (1 shl 6)
else:
  type DeviceFpConfig* {.size: sizeOf(Bitfield), pure.} = enum
    DENORM = (1 shl 0)
    INF_NAN = (1 shl 1)
    ROUND_TO_NEAREST = (1 shl 2)
    ROUND_TO_ZERO = (1 shl 3)
    ROUND_TO_INF = (1 shl 4)
    FMA = (1 shl 5)


type DeviceMemCacheType* {.size: sizeOf(Uint), pure.} = enum
  NONE = 0x0
  READ_ONLY_CACHE = 0x1
  READ_WRITE_CACHE = 0x2


type DeviceLocalMemType* {.size: sizeof(Uint), pure.} = enum
  LOCAL = 0x1
  GLOBAL = 0x2


type DeviceExecCapabilities* {.size: sizeof(Bitfield), pure.} = enum
  KERNEL = (1 shl 0)
  NATIVE_KERNEL = (1 shl 1)


when ApiVersion >= opencl2_0:
  type CommandQueueProperty* {.size: sizeof(Bitfield), pure.} = enum
    OUT_OF_ORDER_EXEC_MODE_ENABLE = (1 shl 0)
    PROFILING_ENABLE = (1 shl 1)
    ON_DEVICE = (1 shl 2)
    ON_DEVICE_DEFAULT = (1 shl 3)
else:
  type CommandQueueProperty* {.size: sizeof(Bitfield), pure.} = enum
    OUT_OF_ORDER_EXEC_MODE_ENABLE = (1 shl 0)
    PROFILING_ENABLE = (1 shl 1)





#  cl_context_info
when ApiVersion >= opencl1_1:
  type ContextInfo* {.size: sizeof(Uint), pure.} = enum
    REFERENCE_COUNT = 0x1080
    DEVICES = 0x1081
    PROPERTIES = 0x1082
    NUM_DEVICES = 0x1083

else:
  type ContextInfo* {.size: sizeof(Uint), pure.} = enum
    REFERENCE_COUNT = 0x1080
    DEVICES = 0x1081
    PROPERTIES = 0x1082




#  cl_context_properties
when ApiVersion >= opencl1_2:
  type ContextProperty* {.size: sizeof(intptr_t), pure.} = enum
    PLATFORM = 0x1084
    INTEROP_USER_SYNC = 0x1085

else:
  type ContextProperty* {.size: sizeof(intptr_t), pure.} = enum
    PLATFORM = 0x1084




when ApiVersion >= opencl1_2:
  #  cl_device_partition_property
  type DevicePartitionProperty* {.size: sizeOf(intptr_t), pure.} = enum
    BY_COUNTS_LIST_END = 0x0
    EQUALLY = 0x1086
    BY_COUNTS = 0x1087
    BY_AFFINITY_DOMAIN = 0x1088


when ApiVersion >= opencl1_2:
  #  cl_device_affinity_domain
  type DeviceAffinityDomain* {.size: sizeOf(Bitfield), pure.} = enum
    NUMA = (1 shl 0)
    L4_CACHE = (1 shl 1)
    L3_CACHE = (1 shl 2)
    L2_CACHE = (1 shl 3)
    L1_CACHE = (1 shl 4)
    NEXT_PARTITIONABLE = (1 shl 5)




when ApiVersion >= opencl2_0:
  #  cl_device_svm_capabilities
  type DeviceSvmCapabilities* {.size: sizeOf(Bitfield), pure.} = enum
    COARSE_GRAIN_BUFFER = (1 shl 0)
    FINE_GRAIN_BUFFER = (1 shl 1)
    FINE_GRAIN_SYSTEM = (1 shl 2)
    ATOMICS = (1 shl 3)

when ApiVersion >= opencl3_0:
  type CommandQueueInfo* {.size: sizeOf(Uint), pure.} = enum
    CONTEXT = 0x1090
    DEVICE = 0x1091
    REFERENCE_COUNT = 0x1092
    PROPERTIES = 0x1093
    SIZE = 0x1094
    DEVICE_DEFAULT = 0x1095
    PROPERTIES_ARRAY = 0x1098
elif ApiVersion >= opencl2_1:
  type CommandQueueInfo* {.size: sizeOf(Uint), pure.} = enum
    CONTEXT = 0x1090
    DEVICE = 0x1091
    REFERENCE_COUNT = 0x1092
    PROPERTIES = 0x1093
    SIZE = 0x1094
    DEVICE_DEFAULT = 0x1095
elif ApiVersion >= opencl2_0:
  type CommandQueueInfo* {.size: sizeOf(Uint), pure.} = enum
    CONTEXT = 0x1090
    DEVICE = 0x1091
    REFERENCE_COUNT = 0x1092
    PROPERTIES = 0x1093
    SIZE = 0x1094
else:
  type CommandQueueInfo* {.size: sizeOf(Uint), pure.} = enum
    CONTEXT = 0x1090
    DEVICE = 0x1091
    REFERENCE_COUNT = 0x1092
    PROPERTIES = 0x1093

when ApiVersion >= opencl2_0:
  type MemFlag* {.size: sizeOf(Bitfield), pure.} = enum
    READ_WRITE
    WRITE_ONLY
    READ_ONLY
    USE_HOST_PTR
    ALLOC_HOST_PTR
    COPY_HOST_PTR
    HOST_WRITE_ONLY
    HOST_READ_ONLY
    HOST_NO_ACCESS
    SVM_FINE_GRAIN_BUFFER #  used by cl_svm_mem_flags only
    SVM_ATOMICS #  used by cl_svm_mem_flags only
    KERNEL_READ_AND_WRITE
  type SvmMemFlag* = MemFlag
elif ApiVersion >= opencl1_2:
  type MemFlag* {.size: sizeOf(Bitfield), pure.} = enum
    READ_WRITE
    WRITE_ONLY
    READ_ONLY
    USE_HOST_PTR
    ALLOC_HOST_PTR
    COPY_HOST_PTR
    HOST_WRITE_ONLY
    HOST_READ_ONLY
    HOST_NO_ACCESS
  type SvmMemFlag* = MemFlag
else:
  type MemFlag* {.size: sizeOf(Bitfield), pure.} = enum
    READ_WRITE
    WRITE_ONLY
    READ_ONLY
    USE_HOST_PTR
    ALLOC_HOST_PTR
    COPY_HOST_PTR
  type SvmMemFlag* = MemFlag



when ApiVersion >= opencl1_2:
  #  cl_mem_migration_flags - bitfield
  type MemMigrationFlag* {.size: sizeOf(Bitfield), pure.} = enum
    MIGRATE_MEM_OBJECT_HOST
    MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED


#  cl_channel_order
when ApiVersion >= opencl2_0:
  type ChannelOrder* {.size: sizeOf(Uint), pure.} = enum
    R = 0x10B0
    A = 0x10B1
    RG = 0x10B2
    RA = 0x10B3
    RGB = 0x10B4
    RGBA = 0x10B5
    BGRA = 0x10B6
    ARGB = 0x10B7
    INTENSITY = 0x10B8
    LUMINANCE = 0x10B9
    Rx = 0x10BA
    RGx = 0x10BB
    RGBx = 0x10BC
    DEPTH = 0x10BD
    sRGB = 0x10BF
    sRGBx = 0x10C0
    sRGBA = 0x10C1
    sBGRA = 0x10C2
    ABGR = 0x10C3
elif ApiVersion >= opencl1_1:
  type ChannelOrder* {.size: sizeOf(Uint), pure.} = enum
    R = 0x10B0
    A = 0x10B1
    RG = 0x10B2
    RA = 0x10B3
    RGB = 0x10B4
    RGBA = 0x10B5
    BGRA = 0x10B6
    ARGB = 0x10B7
    INTENSITY = 0x10B8
    LUMINANCE = 0x10B9
    Rx = 0x10BA
    RGx = 0x10BB
    RGBx = 0x10BC
else:
  type ChannelOrder* {.size: sizeOf(Uint), pure.} = enum
    R = 0x10B0
    A = 0x10B1
    RG = 0x10B2
    RA = 0x10B3
    RGB = 0x10B4
    RGBA = 0x10B5
    BGRA = 0x10B6
    ARGB = 0x10B7
    INTENSITY = 0x10B8
    LUMINANCE = 0x10B9


#  cl_channel_type
when ApiVersion >= opencl2_1:
  type ChannelType* {.size: sizeOf(Uint), pure.} = enum
    SNORM_INT8 = 0x10D0
    SNORM_INT16 = 0x10D1
    UNORM_INT8 = 0x10D2
    UNORM_INT16 = 0x10D3
    UNORM_SHORT_565 = 0x10D4
    UNORM_SHORT_555 = 0x10D5
    UNORM_INT_101010 = 0x10D6
    SIGNED_INT8 = 0x10D7
    SIGNED_INT16 = 0x10D8
    SIGNED_INT32 = 0x10D9
    UNSIGNED_INT8 = 0x10DA
    UNSIGNED_INT16 = 0x10DB
    UNSIGNED_INT32 = 0x10DC
    HALF_FLOAT = 0x10DD
    FLOAT = 0x10DE
    UNORM_INT_101010_2 = 0x10E0
else:
  type ChannelType* {.size: sizeOf(Uint), pure.} = enum
    SNORM_INT8 = 0x10D0
    SNORM_INT16 = 0x10D1
    UNORM_INT8 = 0x10D2
    UNORM_INT16 = 0x10D3
    UNORM_SHORT_565 = 0x10D4
    UNORM_SHORT_555 = 0x10D5
    UNORM_INT_101010 = 0x10D6
    SIGNED_INT8 = 0x10D7
    SIGNED_INT16 = 0x10D8
    SIGNED_INT32 = 0x10D9
    UNSIGNED_INT8 = 0x10DA
    UNSIGNED_INT16 = 0x10DB
    UNSIGNED_INT32 = 0x10DC
    HALF_FLOAT = 0x10DD
    FLOAT = 0x10DE




#  cl_mem_object_type
when ApiVersion >= opencl2_0:
  type MemObjectType* {.size: sizeOf(Uint), pure.} = enum
    BUFFER = 0x10F0
    IMAGE2D = 0x10F1
    IMAGE3D = 0x10F2
    IMAGE2D_ARRAY = 0x10F3
    IMAGE1D = 0x10F4
    IMAGE1D_ARRAY = 0x10F5
    IMAGE1D_BUFFER = 0x10F6
    PIPE = 0x10F7
elif ApiVersion >= opencl1_2:
  type MemObjectType* {.size: sizeOf(Uint), pure.} = enum
    BUFFER = 0x10F0
    IMAGE2D = 0x10F1
    IMAGE3D = 0x10F2
    IMAGE2D_ARRAY = 0x10F3
    IMAGE1D = 0x10F4
    IMAGE1D_ARRAY = 0x10F5
    IMAGE1D_BUFFER = 0x10F6
else:
  type MemObjectType* {.size: sizeOf(Uint), pure.} = enum
    BUFFER = 0x10F0
    IMAGE2D = 0x10F1
    IMAGE3D = 0x10F2




#  cl_mem_info
when ApiVersion >= opencl3_0:
  type MemInfo* {.size: sizeOf(Uint), pure.} = enum
    TYPE = 0x1100
    FLAGS = 0x1101
    SIZE = 0x1102
    HOST_PTR = 0x1103
    MAP_COUNT = 0x1104
    REFERENCE_COUNT = 0x1105
    CONTEXT = 0x1106
    ASSOCIATED_MEMOBJECT = 0x1107
    OFFSET = 0x1108
    USES_SVM_POINTER = 0x1109
    PROPERTIES = 0x110A
elif ApiVersion >= opencl2_0:
  type MemInfo* {.size: sizeOf(Uint), pure.} = enum
    TYPE = 0x1100
    FLAGS = 0x1101
    SIZE = 0x1102
    HOST_PTR = 0x1103
    MAP_COUNT = 0x1104
    REFERENCE_COUNT = 0x1105
    CONTEXT = 0x1106
    ASSOCIATED_MEMOBJECT = 0x1107
    OFFSET = 0x1108
    USES_SVM_POINTER = 0x1109
elif ApiVersion >= opencl1_1:
  type MemInfo* {.size: sizeOf(Uint), pure.} = enum
    TYPE = 0x1100
    FLAGS = 0x1101
    SIZE = 0x1102
    HOST_PTR = 0x1103
    MAP_COUNT = 0x1104
    REFERENCE_COUNT = 0x1105
    CONTEXT = 0x1106
    ASSOCIATED_MEMOBJECT = 0x1107
    OFFSET = 0x1108
else:
  type MemInfo* {.size: sizeOf(Uint), pure.} = enum
    TYPE = 0x1100
    FLAGS = 0x1101
    SIZE = 0x1102
    HOST_PTR = 0x1103
    MAP_COUNT = 0x1104
    REFERENCE_COUNT = 0x1105
    CONTEXT = 0x1106





#  cl_image_info
when ApiVersion >= opencl1_2:
  type ImageInfo* {.size: sizeOf(Uint), pure.} = enum
    FORMAT = 0x1110
    ELEMENT_SIZE = 0x1111
    ROW_PITCH = 0x1112
    SLICE_PITCH = 0x1113
    WIDTH = 0x1114
    HEIGHT = 0x1115
    DEPTH = 0x1116
    ARRAY_SIZE = 0x1117
    BUFFER = 0x1118
    NUM_MIP_LEVELS = 0x1119
    NUM_SAMPLES = 0x111A
else:
  type ImageInfo* {.size: sizeOf(Uint), pure.} = enum
    FORMAT = 0x1110
    ELEMENT_SIZE = 0x1111
    ROW_PITCH = 0x1112
    SLICE_PITCH = 0x1113
    WIDTH = 0x1114
    HEIGHT = 0x1115
    DEPTH = 0x1116




#  cl_pipe_info
when ApiVersion >= opencl3_0:
  type PipeInfo* {.size: sizeOf(Uint), pure.} = enum
    PACKET_SIZE = 0x1120
    MAX_PACKETS = 0x1121
    PROPERTIES = 0x1122
elif ApiVersion >= opencl2_0:
  type PipeInfo* {.size: sizeOf(Uint), pure.} = enum
    PACKET_SIZE = 0x1120
    MAX_PACKETS = 0x1121



#  cl_addressing_mode
when ApiVersion >= opencl1_1:
  type AddressingMode* {.size: sizeOf(Uint), pure.} = enum
    NONE = 0x1130
    CLAMP_TO_EDGE = 0x1131
    CLAMP = 0x1132
    REPEAT = 0x1133
    MIRRORED_REPEAT = 0x1134
else:
  type AddressingMode* {.size: sizeOf(Uint), pure.} = enum
    NONE = 0x1130
    CLAMP_TO_EDGE = 0x1131
    CLAMP = 0x1132
    REPEAT = 0x1133


#  cl_filter_mode
type FilterMode* {.size: sizeOf(Uint), pure.} = enum
  NEAREST = 0x1140
  LINEAR = 0x1141


#  cl_sampler_info
when ApiVersion >= opencl3_0:
  type SamplerInfo* {.size: sizeOf(Uint), pure.} = enum
    ##[The enumerants `MIP_FILTER_MODE, LOD_MIN, LOD_MAX` are for the
       cl_khr_mipmap_image extension.
       They have since been added to cl_ext.h with an appropriate KHR suffix,
       but are left here for backwards compatibility.]##
    REFERENCE_COUNT = 0x1150
    CONTEXT = 0x1151
    NORMALIZED_COORDS = 0x1152
    ADDRESSING_MODE = 0x1153
    FILTER_MODE = 0x1154
    MIP_FILTER_MODE = 0x1155
    LOD_MIN = 0x1156
    LOD_MAX = 0x1157
    PROPERTIES = 0x1158
elif ApiVersion >= opencl2_0:
  type SamplerInfo* {.size: sizeOf(Uint), pure.} = enum
    ##[The enumerants `MIP_FILTER_MODE, LOD_MIN, LOD_MAX` are for the
       cl_khr_mipmap_image extension.
       They have since been added to cl_ext.h with an appropriate KHR suffix,
       but are left here for backwards compatibility.]##
    REFERENCE_COUNT = 0x1150
    CONTEXT = 0x1151
    NORMALIZED_COORDS = 0x1152
    ADDRESSING_MODE = 0x1153
    FILTER_MODE = 0x1154
    MIP_FILTER_MODE = 0x1155
    LOD_MIN = 0x1156
    LOD_MAX = 0x1157
else:
  type SamplerInfo* {.size: sizeOf(Uint), pure.} = enum
    REFERENCE_COUNT = 0x1150
    CONTEXT = 0x1151
    NORMALIZED_COORDS = 0x1152
    ADDRESSING_MODE = 0x1153
    FILTER_MODE = 0x1154


when ApiVersion >= opencl1_2:
  type MapFlag* {.size: sizeOf(Bitfield), pure.} = enum
    READ
    WRITE
    WRITE_INVALIDATE_REGION
else:
  type MapFlag* {.size: sizeOf(Bitfield), pure.} = enum
    READ
    WRITE



when ApiVersion >= opencl2_2:
  type ProgramInfo* {.size: sizeOf(Uint), pure.} = enum
    REFERENCE_COUNT = 0x1160
    CONTEXT = 0x1161
    NUM_DEVICES = 0x1162
    DEVICES = 0x1163
    SOURCE = 0x1164
    BINARY_SIZES = 0x1165
    BINARIES = 0x1166
    NUM_KERNELS = 0x1167
    KERNEL_NAMES = 0x1168
    IL = 0x1169
    SCOPE_GLOBAL_CTORS_PRESENT = 0x116A
    SCOPE_GLOBAL_DTORS_PRESENT = 0x116B
elif ApiVersion >= opencl2_1:
  type ProgramInfo* {.size: sizeOf(Uint), pure.} = enum
    REFERENCE_COUNT = 0x1160
    CONTEXT = 0x1161
    NUM_DEVICES = 0x1162
    DEVICES = 0x1163
    SOURCE = 0x1164
    BINARY_SIZES = 0x1165
    BINARIES = 0x1166
    NUM_KERNELS = 0x1167
    KERNEL_NAMES = 0x1168
    IL = 0x1169
elif ApiVersion >= opencl1_2:
  type ProgramInfo* {.size: sizeOf(Uint), pure.} = enum
    REFERENCE_COUNT = 0x1160
    CONTEXT = 0x1161
    NUM_DEVICES = 0x1162
    DEVICES = 0x1163
    SOURCE = 0x1164
    BINARY_SIZES = 0x1165
    BINARIES = 0x1166
    NUM_KERNELS = 0x1167
    KERNEL_NAMES = 0x1168
else:
  type ProgramInfo* {.size: sizeOf(Uint), pure.} = enum
    REFERENCE_COUNT = 0x1160
    CONTEXT = 0x1161
    NUM_DEVICES = 0x1162
    DEVICES = 0x1163
    SOURCE = 0x1164
    BINARY_SIZES = 0x1165
    BINARIES = 0x1166


when ApiVersion >= opencl2_0:
  type ProgramBuildInfo* {.size: sizeOf(Uint), pure.} = enum
    STATUS = 0x1181
    OPTIONS = 0x1182
    LOG = 0x1183
    BINARY_TYPE = 0x1184
    GLOBAL_VARIABLE_TOTAL_SIZE = 0x1185
elif ApiVersion >= opencl1_2:
  type ProgramBuildInfo* {.size: sizeOf(Uint), pure.} = enum
    STATUS = 0x1181
    OPTIONS = 0x1182
    LOG = 0x1183
    BINARY_TYPE = 0x1184
else:
  type ProgramBuildInfo* {.size: sizeOf(Uint), pure.} = enum
    STATUS = 0x1181
    OPTIONS = 0x1182
    LOG = 0x1183


when ApiVersion >= opencl1_2:
  type ProgramBinaryType* {.size: sizeOf(Uint), pure.} = enum
    NONE = 0x0
    COMPILED_OBJECT = 0x1
    LIBRARY = 0x2
    EXECUTABLE = 0x4


type BuildStatus* {.size: sizeOf(Int), pure.} = enum
  IN_PROGRESS = -3
  ERROR = -2
  NONE = -1
  SUCCESS = 0

when ApiVersion >= opencl1_2:
  type KernelInfo* {.size: sizeOf(Uint), pure.} = enum
    FUNCTION_NAME = 0x1190
    NUM_ARGS = 0x1191
    REFERENCE_COUNT = 0x1192
    CONTEXT = 0x1193
    PROGRAM = 0x1194
    ATTRIBUTES = 0x1195
else:
  type KernelInfo* {.size: sizeOf(Uint), pure.} = enum
    FUNCTION_NAME = 0x1190
    NUM_ARGS = 0x1191
    REFERENCE_COUNT = 0x1192
    CONTEXT = 0x1193
    PROGRAM = 0x1194


when ApiVersion >= opencl1_2:
  type KernelArgInfo* {.size: sizeOf(Uint), pure.} = enum
    ADDRESS_QUALIFIER = 0x1196
    ACCESS_QUALIFIER = 0x1197
    TYPE_NAME = 0x1198
    TYPE_QUALIFIER = 0x1199
    NAME = 0x119A



when ApiVersion >= opencl1_2:
  type KernelArgAddressQualifier* {.size: sizeOf(Uint), pure.} = enum
    GLOBAL = 0x119B
    LOCAL = 0x119C
    CONSTANT = 0x119D
    PRIVATE = 0x119E




when ApiVersion >= opencl1_2:
  type KernelArgAccessQualifier* {.size: sizeOf(Uint), pure.} = enum
    READ_ONLY = 0x11A0
    WRITE_ONLY = 0x11A1
    READ_WRITE = 0x11A2
    NONE = 0x11A3



when ApiVersion >= opencl2_0:
  type KernelArgTypeQualifier* {.size: sizeOf(Bitfield), pure.} = enum
    CONST
    RESTRICT
    VOLATILE
    PIPE
elif ApiVersion >= opencl1_2:
  type KernelArgTypeQualifier* {.size: sizeOf(Bitfield), pure.} = enum
    CONST
    RESTRICT
    VOLATILE




when ApiVersion >= opencl1_2:
  type KernelWorkGroupInfo* {.size: sizeOf(Uint), pure.} = enum
    WORK_GROUP_SIZE = 0x11B0
    COMPILE_WORK_GROUP_SIZE = 0x11B1
    LOCAL_MEM_SIZE = 0x11B2
    PREFERRED_WORK_GROUP_SIZE_MULTIPLE = 0x11B3
    PRIVATE_MEM_SIZE = 0x11B4
    GLOBAL_WORK_SIZE = 0x11B5
else:
  type KernelWorkGroupInfo* {.size: sizeOf(Uint), pure.} = enum
    WORK_GROUP_SIZE = 0x11B0
    COMPILE_WORK_GROUP_SIZE = 0x11B1
    LOCAL_MEM_SIZE = 0x11B2
    PREFERRED_WORK_GROUP_SIZE_MULTIPLE = 0x11B3
    PRIVATE_MEM_SIZE = 0x11B4


when ApiVersion >= opencl2_1:
  type KernelSubGroupInfo* {.size: sizeOf(Uint), pure.} = enum
    LOCAL_SIZE_FOR_SUB_GROUP_COUNT = 0x11B8
    MAX_NUM_SUB_GROUPS = 0x11B9
    COMPILE_NUM_SUB_GROUPS = 0x11BA
    MAX_SUB_GROUP_SIZE_FOR_NDRANGE = 0x2033
    SUB_GROUP_COUNT_FOR_NDRANGE = 0x2034

when ApiVersion >= opencl2_0:
  type KernelExecInfo* {.size: sizeOf(Uint), pure.} = enum
    PTRS = 0x11B6
    FINE_GRAIN_SYSTEM = 0x11B7




when ApiVersion >= opencl1_1:
  type EventInfo* {.size: sizeOf(Uint), pure.} = enum
    COMMAND_QUEUE = 0x11D0
    COMMAND_TYPE = 0x11D1
    REFERENCE_COUNT = 0x11D2
    COMMAND_EXECUTION_STATUS = 0x11D3
    CONTEXT = 0x11D4
else:
  type EventInfo* {.size: sizeOf(Uint), pure.} = enum
    COMMAND_QUEUE = 0x11D0
    COMMAND_TYPE = 0x11D1
    REFERENCE_COUNT = 0x11D2
    COMMAND_EXECUTION_STATUS = 0x11D3


when ApiVersion >= opencl3_0:
  type CommandType* {.size: sizeOf(Uint), pure.} = enum
    NDRANGE_KERNEL = 0x11F0
    TASK = 0x11F1
    NATIVE_KERNEL = 0x11F2
    READ_BUFFER = 0x11F3
    WRITE_BUFFER = 0x11F4
    COPY_BUFFER = 0x11F5
    READ_IMAGE = 0x11F6
    WRITE_IMAGE = 0x11F7
    COPY_IMAGE = 0x11F8
    COPY_IMAGE_TO_BUFFER = 0x11F9
    COPY_BUFFER_TO_IMAGE = 0x11FA
    MAP_BUFFER = 0x11FB
    MAP_IMAGE = 0x11FC
    UNMAP_MEM_OBJECT = 0x11FD
    MARKER = 0x11FE
    ACQUIRE_GL_OBJECTS = 0x11FF
    RELEASE_GL_OBJECTS = 0x1200
    READ_BUFFER_RECT = 0x1201
    WRITE_BUFFER_RECT = 0x1202
    COPY_BUFFER_RECT = 0x1203
    USER = 0x1204
    BARRIER = 0x1205
    MIGRATE_MEM_OBJECTS = 0x1206
    FILL_BUFFER = 0x1207
    FILL_IMAGE = 0x1208
    SVM_FREE = 0x1209
    SVM_MEMCPY = 0x120A
    SVM_MEMFILL = 0x120B
    SVM_MAP = 0x120C
    SVM_UNMAP = 0x120D
    SVM_MIGRATE_MEM = 0x120E
elif ApiVersion >= opencl2_0:
  type CommandType* {.size: sizeOf(Uint), pure.} = enum
    NDRANGE_KERNEL = 0x11F0
    TASK = 0x11F1
    NATIVE_KERNEL = 0x11F2
    READ_BUFFER = 0x11F3
    WRITE_BUFFER = 0x11F4
    COPY_BUFFER = 0x11F5
    READ_IMAGE = 0x11F6
    WRITE_IMAGE = 0x11F7
    COPY_IMAGE = 0x11F8
    COPY_IMAGE_TO_BUFFER = 0x11F9
    COPY_BUFFER_TO_IMAGE = 0x11FA
    MAP_BUFFER = 0x11FB
    MAP_IMAGE = 0x11FC
    UNMAP_MEM_OBJECT = 0x11FD
    MARKER = 0x11FE
    ACQUIRE_GL_OBJECTS = 0x11FF
    RELEASE_GL_OBJECTS = 0x1200
    READ_BUFFER_RECT = 0x1201
    WRITE_BUFFER_RECT = 0x1202
    COPY_BUFFER_RECT = 0x1203
    USER = 0x1204
    BARRIER = 0x1205
    MIGRATE_MEM_OBJECTS = 0x1206
    FILL_BUFFER = 0x1207
    FILL_IMAGE = 0x1208
    SVM_FREE = 0x1209
    SVM_MEMCPY = 0x120A
    SVM_MEMFILL = 0x120B
    SVM_MAP = 0x120C
    SVM_UNMAP = 0x120D
elif ApiVersion >= opencl1_2:
  type CommandType* {.size: sizeOf(Uint), pure.} = enum
    NDRANGE_KERNEL = 0x11F0
    TASK = 0x11F1
    NATIVE_KERNEL = 0x11F2
    READ_BUFFER = 0x11F3
    WRITE_BUFFER = 0x11F4
    COPY_BUFFER = 0x11F5
    READ_IMAGE = 0x11F6
    WRITE_IMAGE = 0x11F7
    COPY_IMAGE = 0x11F8
    COPY_IMAGE_TO_BUFFER = 0x11F9
    COPY_BUFFER_TO_IMAGE = 0x11FA
    MAP_BUFFER = 0x11FB
    MAP_IMAGE = 0x11FC
    UNMAP_MEM_OBJECT = 0x11FD
    MARKER = 0x11FE
    ACQUIRE_GL_OBJECTS = 0x11FF
    RELEASE_GL_OBJECTS = 0x1200
    READ_BUFFER_RECT = 0x1201
    WRITE_BUFFER_RECT = 0x1202
    COPY_BUFFER_RECT = 0x1203
    USER = 0x1204
    BARRIER = 0x1205
    MIGRATE_MEM_OBJECTS = 0x1206
    FILL_BUFFER = 0x1207
    FILL_IMAGE = 0x1208
elif ApiVersion >= opencl1_1:
  type CommandType* {.size: sizeOf(Uint), pure.} = enum
    NDRANGE_KERNEL = 0x11F0
    TASK = 0x11F1
    NATIVE_KERNEL = 0x11F2
    READ_BUFFER = 0x11F3
    WRITE_BUFFER = 0x11F4
    COPY_BUFFER = 0x11F5
    READ_IMAGE = 0x11F6
    WRITE_IMAGE = 0x11F7
    COPY_IMAGE = 0x11F8
    COPY_IMAGE_TO_BUFFER = 0x11F9
    COPY_BUFFER_TO_IMAGE = 0x11FA
    MAP_BUFFER = 0x11FB
    MAP_IMAGE = 0x11FC
    UNMAP_MEM_OBJECT = 0x11FD
    MARKER = 0x11FE
    ACQUIRE_GL_OBJECTS = 0x11FF
    RELEASE_GL_OBJECTS = 0x1200
    READ_BUFFER_RECT = 0x1201
    WRITE_BUFFER_RECT = 0x1202
    COPY_BUFFER_RECT = 0x1203
    USER = 0x1204
else:
  type CommandType* {.size: sizeOf(Uint), pure.} = enum
    NDRANGE_KERNEL = 0x11F0
    TASK = 0x11F1
    NATIVE_KERNEL = 0x11F2
    READ_BUFFER = 0x11F3
    WRITE_BUFFER = 0x11F4
    COPY_BUFFER = 0x11F5
    READ_IMAGE = 0x11F6
    WRITE_IMAGE = 0x11F7
    COPY_IMAGE = 0x11F8
    COPY_IMAGE_TO_BUFFER = 0x11F9
    COPY_BUFFER_TO_IMAGE = 0x11FA
    MAP_BUFFER = 0x11FB
    MAP_IMAGE = 0x11FC
    UNMAP_MEM_OBJECT = 0x11FD
    MARKER = 0x11FE
    ACQUIRE_GL_OBJECTS = 0x11FF
    RELEASE_GL_OBJECTS = 0x1200


type CommandExecutionStatus* {.size: sizeOf(Int), pure.} = enum
  COMPLETE = 0x0
  RUNNING = 0x1
  SUBMITTED = 0x2
  QUEUED = 0x3

when ApiVersion >= opencl1_1:
  type BufferCreateType* {.size: sizeOf(Uint), pure.} = enum
    REGION = 0x1220


when ApiVersion >= opencl2_0:
  type ProfilingInfo* {.size: sizeOf(Uint), pure.} = enum
    QUEUED = 0x1280
    SUBMIT = 0x1281
    START = 0x1282
    END = 0x1283
    COMPLETE = 0x1284
else:
  type ProfilingInfo* {.size: sizeOf(Uint), pure.} = enum
    QUEUED = 0x1280
    SUBMIT = 0x1281
    START = 0x1282
    END = 0x1283


when ApiVersion >= opencl3_0:
  type DeviceAtomicCapability* {.size: sizeOf(Bitfield), pure.} = enum
    ORDER_RELAXED
    ORDER_ACQ_REL
    ORDER_SEQ_CST
    SCOPE_WORK_ITEM
    SCOPE_WORK_GROUP
    SCOPE_DEVICE
    SCOPE_ALL_DEVICES



when ApiVersion >= opencl3_0:
  type DeviceDeviceEnqueueCapability* {.size: sizeOf(Bitfield), pure.} = enum
    SUPPORTED
    REPLACEABLE_DEFAULT

# ##  cl_khronos_vendor_id
# type KhronosVendorId* = distinct Uint
#
# func vendorIdCodePlay(): cint {.importc: "CL_KHRONOS_VENDOR_ID_CODEPLAY",
#                                header: "cl.h".}
#
# # This is a const (define), but nim compiler cant read it at compile time.
# let VendorIdCodePlay* = KhronosVendorId(Uint(vendorIdCodePlay()))


when ApiVersion >= opencl3_0:
  type OpenClVersion* = distinct cint

  const
    VERSION_MAJOR_BITS = cint(10)
    VERSION_MINOR_BITS = cint(10)
    VERSION_PATCH_BITS = cint(12)
    VERSION_MAJOR_MASK = cint((1 shl VERSION_MAJOR_BITS) - 1)
    VERSION_MINOR_MASK = cint((1 shl VERSION_MINOR_BITS) - 1)
    VERSION_PATCH_MASK = cint((1 shl VERSION_PATCH_BITS) - 1)


  func version_Major*(version: OpenClVersion): cint =
    (cint(version) shr (Version_Minor_Bits + Version_Patch_Bits))

  func version_Minor*(version: OpenClVersion): cint =
    ((cint(version) shr Version_Patch_Bits) and Version_Minor_Mask)

  func version_Patch*(version: OpenClVersion): cint =
    (cint(version) and Version_Patch_Mask)

  func make_Version*(major, minor, patch: cint): OpenClVersion =
    OpenClVersion ((((major) and Version_Major_Mask) shl
        (Version_Minor_Bits + Version_Patch_Bits)) or
        (((minor) and Version_Minor_Mask) shl Version_Patch_Bits) or
        ((patch) and Version_Patch_Mask))




type
  ImageFormat* {.bycopy.} = object
    imageChannelOrder*: ChannelOrder
    imageChannelDataType*: ChannelType


when ApiVersion >= opencl1_2:
  when ApiVersion >= opencl2_0:
    type
      ImageDesc* {.bycopy.} = object
        ## The image descriptor structure describes the type and dimensions
        ## of the image or image array and is defined as:
        imageType*: MemObjectType
        imageWidth*: csize_t
        imageHeight*: csize_t
        imageDepth*: csize_t
        imageArraySize*: csize_t
        imageRowPitch*: csize_t
        imageSlicePitch*: csize_t
        numMipLevels*: Uint
        numSamples*: Uint
        memObject*: Mem ## union'd as `buffer*: Mem`

    func buffer*(self: ImageDesc): Mem {.inline.} =
      self.memObject

    func buffer*(self: var ImageDesc): var Mem {.inline.} =
      self.memObject

  else:
    type
      ImageDesc* {.bycopy.} = object
        ## The image descriptor structure describes the type and dimensions
        ## of the image or image array and is defined as:
        imageType*: MemObjectType
        imageWidth*: csize_t
        imageHeight*: csize_t
        imageDepth*: csize_t
        imageArraySize*: csize_t
        imageRowPitch*: csize_t
        imageSlicePitch*: csize_t
        numMipLevels*: Uint
        numSamples*: Uint
        buffer*: Mem

when ApiVersion >= opencl1_1:
  type
    BufferRegion* {.bycopy.} = object
      origin*: csize_t
      size*: csize_t

when ApiVersion >= opencl3_0:
  const
    NAME_VERSION_MAX_NAME_SIZE* = 64
  type
    NameVersion* {.bycopy.} = object
      version*: OpenClVersion
      name*: cstring




# ******************************************************************************
#  CL_NO_PROTOTYPES implies CL_NO_CORE_PROTOTYPES:

#  Platform API
proc getPlatformIDs*(
  numEntries: Uint; platforms: ptr UncheckedArray[PlatformId];
  numPlatforms: ptr Uint): ErrorCode
    {.climport.}
      ## Query list of available platforms


proc getPlatformInfo*(
  platform: PlatformId; paramName: PlatformInfo; paramValueSize: csize_t;
  paramValue: cstring;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Query information about an OpenCL platform


#  Device APIs

proc getDeviceIDs*(
  platform: PlatformId; deviceType: set[DeviceType]; numEntries: Uint;
  devices: ptr UncheckedArray[DeviceId];
  numDevices: ptr Uint): ErrorCode
    {.climport.}
      ## Query devices available on a platform

# when ApiVersion >= opencl3_0:
#   type DeviceQueryResult* = DeviceType | Uint | csize_t | Ulong | Bool |
#     NameVersion | DeviceFpConfig | DeviceMemCacheType |
#     DeviceLocalMemType | DeviceExecCapabilities | CommandQueueProperty |
#     PlatformId | OpenClVersion | #[VersionKHR |]# DeviceId |
#     DevicePartitionProperty | set[DeviceAffinityDomain] |
#     set[DeviceSvmCapabilities] |
#     set[DeviceAtomicCapability] | set[DeviceDeviceEnqueueCapability] |
#     set[CommandQueueProperty] | Uchar
# elif ApiVersion >= opencl2_0:
#   type DeviceQueryResult* = DeviceType | Uint | csize_t | Ulong | Bool |
#      DeviceFpConfig | DeviceMemCacheType |
#     DeviceLocalMemType | DeviceExecCapabilities | CommandQueueProperty |
#     PlatformId | OpenClVersion |  #[VersionKHR |]# DeviceId |
#     DevicePartitionProperty | set[DeviceAffinityDomain] |
#     set[DeviceSvmCapabilities] |
#     set[CommandQueueProperty] | Uchar
# else:
#   type DeviceQueryResult* = DeviceType | Uint | csize_t | Ulong | Bool |
#     DeviceFpConfig | DeviceMemCacheType |
#     DeviceLocalMemType | DeviceExecCapabilities | CommandQueueProperty |
#     PlatformId | OpenClVersion |  #[VersionKHR |]# DeviceId |
#     set[CommandQueueProperty] | Uchar

proc getDeviceInfo*(
  device: DeviceId; paramName: DeviceInfo; paramValueSize: csize_t;
  paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Query specific information about a device

when ApiVersion >= opencl1_2:
  proc createSubDevices*(
    inDevice: DeviceId;
    properties: ptr[DevicePartitionProperty];
    numDevices: Uint; outDevices: ptr UncheckedArray[DeviceId];
    numDevicesRet: ptr Uint): ErrorCode
      {.climport.}
        ## Create sub-devices partitioning an OpenCL device


  proc retainDevice*(device: DeviceId): ErrorCode
    {.climport.}
      ## Retain an OpenCL device

  proc releaseDevice*(device: DeviceId): ErrorCode
    {.climport.}
      ## Release an OpenCL device

when ApiVersion >= opencl2_1:
  proc setDefaultDeviceCommandQueue*(
    context: Context; device: DeviceId; commandQueue: CommandQueue): ErrorCode
      {.climport.}
        ## Replaces the default command-queue on the device.

  proc getDeviceAndHostTimer*(
    device: DeviceId; deviceTimestamp: out Ulong;
    hostTimestamp: out Ulong): ErrorCode
      {.climport.}
        ## Query synchronized host and device timestamps
  proc getDeviceAndHostTimer*(
    device: DeviceId; deviceTimestamp: ptr Ulong;
    hostTimestamp: ptr Ulong): ErrorCode
      {.climport.}
        ## Query synchronized host and device timestamps
  proc getDeviceAndHostTimer*(
    device: DeviceId; deviceTimestamp: out Ulong;
    hostTimestamp: ptr Ulong): ErrorCode
      {.climport.}
        ## Query synchronized host and device timestamps
  proc getDeviceAndHostTimer*(
    device: DeviceId; deviceTimestamp: ptr Ulong;
    hostTimestamp: out Ulong): ErrorCode
      {.climport.}
        ## Query synchronized host and device timestamps

  proc getHostTimer*(
    device: DeviceId; hostTimestamp: out Ulong): ErrorCode
      {.climport.}
        ## Query the host clock
  proc getHostTimer*(
    device: DeviceId; hostTimestamp: ptr Ulong): ErrorCode
      {.climport.}
        ## Query the host clock

#  Context APIs

static:
  doAssert sizeOf(PlatformId) == sizeOf(ContextProperty)


type
  ContextCreationPair* {.packed.} = tuple
    property: ContextProperty
    value: PlatformId

proc createContext*(
  properties: ptr UncheckedArray[ContextCreationPair]; numDevices: Uint;
  devices: ptr UncheckedArray[DeviceId];
  pfnNotify: proc (errinfo: cstring;
                   privateInfo: pointer;
                   cb: csize_t; userData: pointer) {.stdcall.};
  userData: pointer; errcodeRet: ptr ErrorCode): Context
    {.climport.}
      ## Create an OpenCL context

proc createContextFromType*(
  properties: ptr UncheckedArray[ContextCreationPair]; deviceType: DeviceType;
  pfnNotify: proc (errinfo: cstring;
                   privateInfo: pointer;
                   cb: csize_t; userData: pointer) {.stdcall.};
  userData: pointer; errcodeRet: ptr Int): Context
    {.climport.}
      ## Create an OpenCL context from a device type

proc retainContext*(context: Context): ErrorCode
  {.climport.}
    ## Retain an OpenCL context

proc releaseContext*(context: Context): ErrorCode
  {.climport.}
    ## Release an OpenCL context

# type ContextQueryResult* = Uint | UncheckedArray[DeviceId] |
#   UncheckedArray[ContextCreationPair]

proc getContextInfo*(
  context: Context; paramName: ContextInfo; paramValueSize: csize_t;
  paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
     ## Query information about an OpenCL context

when ApiVersion >= opencl3_0:
  proc setContextDestructorCallback*(
    context: Context; pfnNotify: proc (context: Context; userData: pointer);
    userData: pointer): ErrorCode
      {.climport.}
        ## Registers a destructor callback function with a context.


#  Command Queue APIs
when ApiVersion >= opencl2_0:
  type
    CommandQueueCreationValue* {.union.} = tuple
      properties: set[CommandQueueProperty]
      sizeVal: Uint
    CommandQueueCreationPropertyPair* {.packed.} = tuple
      property: CommandQueueProperty
      value: CommandQueueCreationValue

  proc createCommandQueueWithProperties*(
    context: Context; device: DeviceId;
    properties: ptr UncheckedArray[CommandQueueCreationPropertyPair];
    errcodeRet: ptr ErrorCode): CommandQueue
      {.climport.}
        ## Create a host or device command-queue on a specific device.


proc retainCommandQueue*(commandQueue: CommandQueue): ErrorCode
  {.climport.}
    ## Increments the command_queue reference count.

proc releaseCommandQueue*(commandQueue: CommandQueue): ErrorCode
  {.climport.}
    ## Decrements the command_queue reference count.

# when ApiVersion >= opencl3_0:
#   type CommandQueueParameterQueryResult* = Context | DeviceId | Uint |
#     set[CommandQueueProperty] | CommandQueue |
#     UncheckedArray[CommandQueueCreationPropertyPair]
# elif ApiVersion >= opencl2_1:
#   type CommandQueueParameterQueryResult* = Context | DeviceId | Uint |
#     set[CommandQueueProperty] | CommandQueue
# else:
#   type CommandQueueParameterQueryResult* = Context | DeviceId | Uint |
#     set[CommandQueueProperty]

proc getCommandQueueInfo*(
  commandQueue: CommandQueue; paramName: CommandQueueInfo;
  paramValueSize: csize_t; paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Query information about a command-queue.

#  Memory Object APIs
proc createBuffer*(
  context: Context; flags: set[MemFlag]; size: csize_t;
  hostPtr: pointer; errcodeRet: ptr ErrorCode): Mem
    {.climport.}
      ## Creates a buffer object.

when ApiVersion >= opencl1_1:
  proc createSubBuffer*(
    buffer: Mem; flags: set[MemFlag]; bufferCreateType: BufferCreateType;
    bufferCreateInfo: ptr BufferRegion;
    errcodeRet: ptr ErrorCode): Mem
      {.climport.}
        ## Creates a new buffer object (referred to as a sub-buffer object)
        ## from an existing buffer object.

when ApiVersion >= opencl1_2:
  proc createImage*(
    context: Context; flags: set[MemFlag]; imageFormat: ptr ImageFormat;
    imageDesc: ptr ImageDesc; hostPtr: pointer;
    errcodeRet: ptr ErrorCode): Mem
      {.climport.}
        ## Creates a 1D image, 1D image buffer, 1D image array, 2D image,
        ## 2D image array or 3D image object.

when ApiVersion >= opencl2_0:
  proc createPipe*(
    context: Context; flags: set[MemFlag]; pipePacketSize, pipeMaxPackets: Uint;
    properties: pointer = nil #[unused]#;
    errcodeRet: ptr ErrorCode): Mem
      {.climport.}
        ## Creates a pipe object.

when ApiVersion >= opencl3_0:
  proc createBufferWithProperties*(
    context: Context; properties: pointer = nil #[unused]#; flags: set[MemFlag];
    size: csize_t; hostPtr: pointer;
    errcodeRet: ptr ErrorCode): Mem
      {.climport.}
        ## Creates a buffer object.

  proc createImageWithProperties*(context: Context;
    properties: pointer = nil #[unused]#; flags: set[MemFlag];
    imageFormat: ptr ImageFormat; imageDesc: ptr ImageDesc;
    hostPtr: pointer; errcodeRet: ptr ErrorCode): Mem
      {.climport.}
        ## Creates a 1D image, 1D image buffer, 1D image array, 2D image,
        ## 2D image array or 3D image object.

proc retainMemObject*(memobj: Mem): ErrorCode
  {.climport.}
    ## Increments the memory object reference count.

proc releaseMemObject*(memobj: Mem): ErrorCode
  {.climport.}
    ## Decrements the memory object reference count.

proc getSupportedImageFormats*(
  context: Context; flags: set[MemFlag]; imageType: MemObjectType;
  numEntries: Uint; imageFormats: ptr UncheckedArray[ImageFormat];
  numImageFormats: ptr Uint): ErrorCode
    {.climport.}
      ## Get the list of image formats supported by an OpenCL implementation.


# when ApiVersion >= opencl2_0:
#   type MemoryObjectInfoQueryResult* = MemObjectType | set[MemFlag] | csize_t |
#     pointer | Uint | Context | Mem | Bool
# elif ApiVersion >= opencl1_1:
#   type MemoryObjectInfoQueryResult* = MemObjectType | set[MemFlag] | csize_t |
#     pointer | Uint | Context | Mem
# else:
#   type MemoryObjectInfoQueryResult* = MemObjectType | set[MemFlag] | csize_t |
#     pointer | Uint | Context

proc getMemObjectInfo*(
  memobj: Mem; paramName: MemInfo; paramValueSize: csize_t;
  paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Get information that is common to all memory objects (buffer and image
      ## objects).

# when ApiVersion >= opencl1_2 and UseDeprecatedOpenCl1_2Apis:
#   type ImageObjQueryResult* = ImageFormat | csize_t | Uint | Mem
# elif ApiVersion >= opencl1_2:
#   type ImageObjQueryResult* = ImageFormat | csize_t | Uint
# else:
#   type ImageObjQueryResult* = ImageFormat | csize_t

# TODO fix doc linking
proc getImageInfo*(
  image: Mem; paramName: ImageInfo; paramValueSize: csize_t;
  paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Get information specific to an image object created with the
      ## `createImage proc <#createImage>`_.

when ApiVersion >= opencl2_0:
  # when ApiVersion >= opencl3_0:
  #   type PipeObjQueryResult* = Uint | pointer # unused
  # else:
  #   type PipeObjQueryResult* = Uint

  proc getPipeInfo*(
    pipe: Mem; paramName: PipeInfo; paramValueSize: csize_t;
    paramValue: pointer;
    paramValueSizeRet: ptr csize_t): ErrorCode
      {.climport.}
        ##  Get information specific to a pipe object created with the
        ## `createPipe proc <#createPipe>`_.


when ApiVersion >= opencl1_1:
  proc setMemObjectDestructorCallback*[T; S: ptr T](
    memobj: Mem; pfnNotify: proc (memobj: Mem; userData: S);
    userData: S): ErrorCode
      {.climport.}
        ## Registers a destructor callback function with a memory object.

#  SVM Allocation APIs
when ApiVersion >= opencl2_0:
  type SvmPointer* = distinct pointer
    ##[A pointer to a shared virtual memory (SVM) buffer that can be shared by
      the host and all devices in an OpenCL context that support shared
      virtual memory.]##
    #[using a distinct pointer type here, mostly to underscore the fact that we
      cant entirely use svm pointers the same as other pointers.
      We should prohibit ourselves from using these pointers incorrectly as much
      as possible.]#

  converter toPointer*(self: SvmPointer): pointer =
    pointer(self)

  proc dealloc*(p: SvmPointer) {.error: "Must free SvmPointers with svmFree".}
  proc deallocShared*(p: SvmPointer)
    {.error: "Must free SvmPointers with svmFree".}
  proc realloc*(p: SvmPointer; newSize: Natural): pointer
    {.error: "Must use OpenCL procs with SvmPointers".}
  proc realloc0*(p: SvmPointer; oldSize, newSize: Natural): pointer
    {.error: "Must use OpenCL procs with SvmPointers".}
  proc reallocShared*(p: SvmPointer; newSize: Natural): pointer
    {.error: "Must use OpenCL procs with SvmPointers".}
  proc reallocShared0*(p: SvmPointer; oldSize, newSize: Natural): pointer
    {.error: "Must use OpenCL procs with SvmPointers".}

  proc svmAlloc*(
    context: Context; flags: set[SvmMemFlag]; size: csize_t;
    alignment: Uint): SvmPointer
      {.climport.}
        ## Allocates a shared virtual memory (SVM) buffer that can be shared by
        ## the host and all devices in an OpenCL context that support shared
        ## virtual memory.

  proc svmFree*(context: Context; svmPointer: SvmPointer)
    {.climport.}
      ## Frees a shared virtual memory buffer allocated using the
      ## `svmAlloc proc <#svmAlloc>`_.

#  Sampler APIs
when ApiVersion >= opencl2_0:
  type
    SamplerProperty* {.size: sizeOf(Ulong), pure.} = enum
      NORMALIZED_COORDS = 0x1152
      ADDRESSING_MODE = 0x1153
      FILTER_MODE = 0x1154
      MIP_FILTER_MODE = 0x1155
      LOD_MIN = 0x1156
      LOD_MAX = 0x1157

    SamplerPropertyValue {.union.} = tuple
      normalizedCoords: Bool
      addrMode: AddressingMode
      filterMode: FilterMode

    SamplerPropertyPair* {.packed.} = tuple
      property: SamplerProperty
      value: SamplerPropertyValue


  proc createSamplerWithProperties*(
    context: Context;
    samplerProperties: ptr UncheckedArray[SamplerPropertyPair];
    errcodeRet: ptr ErrorCode): Sampler
      {.climport.}
        ## Creates a sampler object.

proc retainSampler*(sampler: Sampler): ErrorCode
  {.climport.}
    ## Increments the sampler reference count.

proc releaseSampler*(sampler: Sampler): ErrorCode
  {.climport.}
    ## Decrements the sampler reference count.

# when ApiVersion >= opencl3_0:
#   type SamplerObjQueryResult* = Uint | Context | Bool | AddressingMode |
#     FilterMode | UncheckedArray[SamplerPropertyPair]
# elif ApiVersion >= opencl2_0:
#   type SamplerObjQueryResult* = Uint | Context | Bool | AddressingMode |
#     FilterMode | UncheckedArray[SamplerPropertyPair]
# else:
#     type SamplerObjQueryResult* = Uint | Context | Bool | AddressingMode |
#     FilterMode

proc getSamplerInfo*(
  sampler: Sampler; paramName: SamplerInfo; paramValueSize: csize_t;
  paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Returns information about the sampler object.



#  Program Object APIs
proc createProgramWithSource*(
  context: Context; count: Uint; strings: cstringArray;
  lengths: ptr UncheckedArray[csize_t];
  errcodeRet: ptr ErrorCode): Program
    {.climport.}
      ## Creates a program object for a context, and loads source code
      ## specified by text strings into the program object.

proc createProgramWithBinary*(
  context: Context; numDevices: Uint; deviceList: ptr UncheckedArray[DeviceId];
  lengths: ptr UncheckedArray[csize_t];
  binaries: ptr UncheckedArray[ptr UncheckedArray[byte]];
  binaryStatus: ptr UncheckedArray[ErrorCode];
  errcodeRet: ptr ErrorCode): Program
    {.climport.}
      ## Creates a program object for a context, and loads binary bits into
      ## the program object.

when ApiVersion >= opencl1_2:
  proc createProgramWithBuiltInKernels*(
    context: Context; numDevices: Uint;
    deviceList: ptr UncheckedArray[DeviceId];
    kernelNames: cstring; errcodeRet: ptr ErrorCode): Program
      {.climport.}
        ## Creates a program object for a context, and loads the information
        ## related to the built-in kernels into a program object.

when ApiVersion >= opencl2_1:
  proc createProgramWithIL*(
    context: Context; il: ptr UncheckedArray[byte]; length: csize_t;
    errcodeRet: ptr ErrorCode): Program
      {.climport.}
        ## Creates a program object for a context, and loads the IL into the
        ## program object.

proc retainProgram*(program: Program): ErrorCode
  {.climport.}
    ## Increments the program reference count.

proc releaseProgram*(program: Program): ErrorCode
  {.climport.}
    ## Decrements the program reference count.

proc buildProgram*(
  program: Program; numDevices: Uint; deviceList: ptr UncheckedArray[DeviceId];
  options: cstring; pfnNotify: proc (program: Program; userData: pointer);
  userData: pointer): ErrorCode {.climport.}
    ## Builds (compiles and links) a program executable from the program
    ## source or binary.

when ApiVersion >= opencl1_2:
  proc compileProgram*(
    program: Program; numDevices: Uint;
    deviceList: ptr UncheckedArray[DeviceId];
    options: cstring; numInputHeaders: Uint;
    inputHeaders: ptr UncheckedArray[Program];
    headerIncludeNames: cstringArray;
    pfnNotify: proc (program: Program; userData: pointer);
    userData: pointer): ErrorCode {.climport.}
      ## Compiles a program's source for all the devices or a specific device(s)
      ## in the OpenCL context associated with a program.

  proc linkProgram*(
    context: Context; numDevices: Uint;
    deviceList: ptr UncheckedArray[DeviceId];
    options: cstring; numInputPrograms: Uint;
    inputPrograms: ptr UncheckedArray[Program];
    pfnNotify: proc (program: Program; userData: pointer); userData: pointer;
    errcodeRet: ptr ErrorCode): Program
      {.climport.}
        ## Links a set of compiled program objects and libraries for all the
        ## devices or a specific device(s) in the OpenCL context and creates a
        ## library or executable.


when ApiVersion >= opencl2_2:
  proc setProgramReleaseCallback*(
    program: Program; pfnNotify: proc (program: Program; userData: pointer);
    userData: pointer): ErrorCode
      {.climport.}
        ## Registers a destructor callback function with a program object.

  proc setProgramSpecializationConstant*[T](
    program: Program; specId: Uint; specSize: csize_t = csize_t(sizeOf(T));
    specValue: ptr T): ErrorCode
      {.climport.}

when ApiVersion >= opencl1_2:
  proc unloadPlatformCompiler*(platform: PlatformId): ErrorCode
    {.climport.}
      ## Allows the implementation to release the resources allocated by the
      ## OpenCL compiler for a platform.

# when ApiVersion >= opencl2_2 and UseDeprecatedOpenCl2_2Apis:
#   type ProgramObjQueryResult* = Uint | Context | UncheckedArray[DeviceId] |
#     cstring | UncheckedArray[csize_t] | UncheckedArray[byte] | csize_t |
#     Bool
# elif ApiVersion >= opencl1_2:
#   type ProgramObjQueryResult* = Uint | Context | UncheckedArray[DeviceId] |
#     cstring | UncheckedArray[csize_t] | UncheckedArray[byte] | csize_t
# else:
#   type ProgramObjQueryResult* = Uint | Context | UncheckedArray[DeviceId] |
#     cstring | UncheckedArray[csize_t] | UncheckedArray[byte]

proc getProgramInfo*(
  program: Program; paramName: ProgramInfo; paramValueSize: csize_t;
  paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Returns information about the program object.

# when ApiVersion >= opencl2_0:
#   type ProgramBuildQueryResult* = BuildStatus | cstring | ProgramBinaryType |
#     csize_t
# elif ApiVersion >= opencl1_2:
#   type ProgramBuildQueryResult* = BuildStatus | cstring | ProgramBinaryType
# else:
#   type ProgramBuildQueryResult* = BuildStatus | cstring

proc getProgramBuildInfo*(
  program: Program; device: DeviceId; paramName: ProgramBuildInfo;
  paramValueSize: csize_t; paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Returns build information for each device in the program object.

#  Kernel Object APIs
proc createKernel*(
  program: Program; kernelName: cstring;
  errcodeRet: ptr ErrorCode): Kernel
    {.climport.}
      ## Creates a kernel object.

proc createKernelsInProgram*(
  program: Program; numKernels: Uint; kernels: ptr UncheckedArray[Kernel];
  numKernelsRet: ptr Uint): ErrorCode
    {.climport.}
      ## Creates kernel objects for all kernel functions in a program object.

when ApiVersion >= opencl2_1:
  proc cloneKernel*(
    sourceKernel: Kernel; errcodeRet: ptr ErrorCode): Kernel
      {.climport.}
        ## Make a shallow copy of the kernel object.

proc retainKernel*(kernel: Kernel): ErrorCode
  {.climport.}
    ## Increments the kernel object reference count.

proc releaseKernel*(kernel: Kernel): ErrorCode
  {.climport.}
    ## Decrements the kernel reference count.

proc setKernelArg*(
  kernel: Kernel; argIndex: Uint; argSize: csize_t;
  argValue: pointer): ErrorCode
    {.climport.}
      ## Set the argument value for a specific argument of a kernel.


when ApiVersion >= opencl2_0:
  proc setKernelArgSVMPointer*(
    kernel: Kernel; argIndex: Uint; argValue: SvmPointer): ErrorCode
      {.climport.}
        ## Set a SVM pointer as the argument value for a specific
        ## argument of a kernel.

  proc setKernelArg*(
    kernel: Kernel; argIndex: Uint; argValue: SvmPointer): ErrorCode
      {.climport.}
        ## Set a SVM pointer as the argument value for a specific
        ## argument of a kernel.

  proc setKernelExecInfo*(
    kernel: Kernel; paramName: KernelExecInfo;
    paramValueSize: csize_t; paramValue: pointer): ErrorCode
      {.climport.}
        ## Pass additional information other than argument values to a kernel.


# type KernelObjQueryResult* = cstring | Uint | Context | Program

proc getKernelInfo*(
  kernel: Kernel; paramName: KernelInfo; paramValueSize: csize_t;
  paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Returns information about the kernel object.

when ApiVersion >= opencl1_2:
  # type KernelArgQueryResult* = KernelArgAddressQualifier | cstring|
  #   KernelArgAccessQualifier | KernelArgTypeQualifier

  proc getKernelArgInfo*(
    kernel: Kernel; argIndx: Uint; paramName: KernelArgInfo;
    paramValueSize: csize_t; paramValue: pointer;
    paramValueSizeRet: ptr csize_t): ErrorCode
      {.climport.}
        ## Returns information about the arguments of a kernel.


# type KernelObjDeviceQueryResult* = UncheckedArray[csize_t] | csize_t | Ulong

proc getKernelWorkGroupInfo*(
  kernel: Kernel; device: DeviceId; paramName: KernelWorkGroupInfo;
  paramValueSize: csize_t; paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Returns information about the kernel object that may be specific
      ## to a device.


when ApiVersion >= opencl2_1:
  proc getKernelSubGroupInfo*(
    kernel: Kernel; device: DeviceId; paramName: KernelSubGroupInfo;
    inputValueSize: csize_t; inputValue: ptr UncheckedArray[csize_t];
    paramValueSize: csize_t; paramValue,
    paramValueSizeRet: ptr csize_t): ErrorCode
      {.climport.}
        ## Returns information about the kernel object.

  proc getKernelSubGroupInfo*(
    kernel: Kernel; device: DeviceId; paramName: KernelSubGroupInfo;
    inputValueSize: csize_t; inputValue: csize_t;
    paramValueSize: csize_t; paramValue: ptr UncheckedArray[csize_t];
    paramValueSizeRet: ptr csize_t): ErrorCode
      {.climport.}
        ## Returns information about the kernel object.



#  Event Object APIs
proc waitForEvents*(
  numEvents: Uint; eventList: ptr UncheckedArray[Event]): ErrorCode
    {.climport.}
      ## Waits on the host thread for commands identified by event objects
      ## to complete.

# when ApiVersion >= opencl1_1:
#   type EventObjQueryResult* = CommandQueue | Context | CommandType | Int | Uint
# else:
#   type EventObjQueryResult* = CommandQueue | CommandType | Int | Uint

proc getEventInfo*(
  event: Event; paramName: EventInfo; paramValueSize: csize_t;
  paramValue: pointer;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Returns information about the event object.

when ApiVersion >= opencl1_1:
  proc createUserEvent*(
    context: Context; errcodeRet: ptr ErrorCode): Event
      {.climport.}
        ## Creates a user event object.

proc retainEvent*(event: Event): ErrorCode
  {.climport.}
    ## Increments the event reference count.

proc releaseEvent*(event: Event): ErrorCode
  {.climport.}
    ## Decrements the event reference count.


when ApiVersion >= opencl1_1:
  type ExecutionStatus* = concept x
    x is enum
    sizeOf(x) == sizeOf(Int)

  proc setUserEventStatus*[T: ExecutionStatus|Int](
    event: Event; executionStatus: T): ErrorCode
      {.climport.}
        ## Sets the execution status of a user event object.

  proc setEventCallback*[T: ExecutionStatus|Int; S](
    event: Event; commandExecCallbackType: T;
    pfnNotify: proc (event: Event; eventCommandStatus: T; userData: ptr S);
    userData: ptr S): ErrorCode {.climport.}
      ## Registers a user callback function for a specific command
      ## execution status.



#  Profiling APIs

proc getEventProfilingInfo*(
  event: Event; paramName: ProfilingInfo;
  paramValueSize: csize_t; paramValue: ptr Ulong;
  paramValueSizeRet: ptr csize_t): ErrorCode
    {.climport.}
      ## Returns profiling information for the command associated with event
      ## if profiling is enabled.


#  Flush and Finish APIs
proc flush*(commandQueue: CommandQueue): ErrorCode
  {.climport.}
    ## Issues all previously queued OpenCL commands in a command-queue to the
    ## device associated with the command-queue.

proc finish*(commandQueue: CommandQueue): ErrorCode
  {.climport.}
    ## Blocks until all previously queued OpenCL commands in a command-queue
    ## are issued to the associated device and have completed.


#  Enqueued Commands APIs
proc enqueueReadBuffer*(
  commandQueue: CommandQueue; buffer: Mem; blockingRead: Bool;
  offset, size: csize_t; `ptr`: pointer; numEventsInWaitList: Uint;
  eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ## Enqueue commands to read from a buffer object to host memory.


when ApiVersion >= opencl1_1:
  proc enqueueReadBufferRect*[T](
    commandQueue: CommandQueue; buffer: Mem; blockingRead: Bool;
    bufferOrigin, hostOrigin, region: ptr UncheckedArray[csize_t];
    bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch: csize_t;
    `ptr`: pointer; numEventsInWaitList: Uint;
    eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueue command to read from a 2D or 3D rectangular region from
        ## a buffer object to host memory.


proc enqueueWriteBuffer*(
  commandQueue: CommandQueue; buffer: Mem; blockingWrite: Bool;
  offset, size: csize_t; `ptr`: pointer; numEventsInWaitList: Uint;
  eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ## Enqueue commands to read from a buffer object to host memory.

when ApiVersion >= opencl1_1:
  proc enqueueWriteBufferRect*[T](
    commandQueue: CommandQueue; buffer: Mem; blockingWrite: Bool;
    bufferOrigin, hostOrigin, region: ptr UncheckedArray[csize_t];
    bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch: csize_t;
    `ptr`: pointer; numEventsInWaitList: Uint;
    eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueue command to read from a 2D or 3D rectangular region from a
        ## buffer object to host memory.

when ApiVersion >= opencl1_2:
  proc enqueueFillBuffer*[T: ScalarTypes|VectorTypes](
    commandQueue: CommandQueue; buffer: Mem; pattern {.byRef.}: T;
    patternSize = csize_t(sizeOf(T)); offset, size: csize_t;
    numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command to fill a buffer object with a pattern
        ## of a given pattern size.

proc enqueueCopyBuffer*(
  commandQueue: CommandQueue; srcBuffer, dstBuffer: Mem;
  srcOffset, dstOffset, size: csize_t; numEventsInWaitList: Uint;
  eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ## Enqueues a command to copy from one buffer object to another.

when ApiVersion >= opencl1_1:
  proc enqueueCopyBufferRect*(
    commandQueue: CommandQueue; srcBuffer, dstBuffer: Mem;
    srcOrigin, dstOrigin, region: ptr csize_t;
    srcRowPitch, srcSlicePitch, dstRowPitch, dstSlicePitch: csize_t;
    numEventsInWaitList: Uint;
    eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command to copy a 2D or 3D rectangular region from a
        ## buffer object to another buffer object.


proc enqueueReadImage*[T](
  commandQueue: CommandQueue; image: Mem; blockingRead: Bool;
  origin, region: ptr UncheckedArray[csize_t]; rowPitch, slicePitch: csize_t;
  `ptr`: pointer; numEventsInWaitList: Uint;
  eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ##  Enqueue commands to read from an image or image array object
      ## to host memory.


proc enqueueWriteImage*[T](
  commandQueue: CommandQueue; image: Mem; blockingWrite: Bool;
  origin, region: ptr UncheckedArray[csize_t];
  inputRowPitch, inputSlicePitch: csize_t; `ptr`: pointer;
  numEventsInWaitList: Uint;
  eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ## Enqueue commands to read from an image or image array object
      ## to host memory.

when ApiVersion >= opencl1_2:
  proc enqueueFillImage*[T: Float|Float4|Int4|Uint4](
    commandQueue: CommandQueue; image: Mem; fillColor: ptr T;
    origin, region: ptr UncheckedArray[csize_t]; numEventsInWaitList: Uint;
    eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command to fill an image object with a specified color.

proc enqueueCopyImage*(
  commandQueue: CommandQueue; srcImage, dstImage: Mem;
  srcOrigin, dstOrigin, region: ptr UncheckedArray[csize_t];
  numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ## Enqueues a command to copy image objects.

proc enqueueCopyImageToBuffer*(
  commandQueue: CommandQueue; srcImage, dstBuffer: Mem;
  srcOrigin, region: ptr UncheckedArray[csize_t]; dstOffset: csize_t;
  numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ## Enqueues a command to copy an image object to a buffer object.

proc enqueueCopyBufferToImage*(
  commandQueue: CommandQueue; srcBuffer, dstImage: Mem; srcOffset: csize_t;
  dstOrigin, region: ptr UncheckedArray[csize_t]; numEventsInWaitList: Uint;
  eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ## Enqueues a command to copy a buffer object to an image object.


proc enqueueMapBuffer*(
  commandQueue: CommandQueue; buffer: Mem; blockingMap: Bool;
  mapFlags: set[MapFlag]; offset, size: csize_t; numEventsInWaitList: Uint;
  eventWaitList: ptr UncheckedArray[Event]; event: ptr Event;
  errcodeRet: ptr ErrorCode): pointer
    {.climport.}
      ## Enqueues a command to map a region of a buffer object into the
      ## host address space and returns a pointer to this mapped region.

proc enqueueMapImage*[T](
  commandQueue: CommandQueue; image: Mem; blockingMap: Bool; mapFlags: set[MapFlag];
  origin, region, imageRowPitch, imageSlicePitch: ptr UncheckedArray[csize_t];
  numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event;
  errcodeRet: ptr ErrorCode): pointer
    {.climport.}
      ## Enqueues a command to map a region of an image object into the
      ## host address space and returns a pointer to this mapped region.

proc enqueueUnmapMemObject*(
  commandQueue: CommandQueue; memobj: Mem; mappedPtr: pointer;
  numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ## Enqueues a command to unmap a previously mapped region of a
      ## memory object.

when ApiVersion >= opencl1_2:
  proc enqueueMigrateMemObjects*(
    commandQueue: CommandQueue; numMemObjects: Uint;
    memObjects: ptr UncheckedArray[Mem]; flags: set[MemMigrationFlag];
    numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command to indicate which device a set of memory objects
        ## should be associated with.

proc enqueueNDRangeKernel*(
  commandQueue: CommandQueue; kernel: Kernel; workDim: Uint;
  globalWorkOffset, globalWorkSize, localWorkSize: ptr UncheckedArray[csize_t];
  numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ## Enqueues a command to execute a kernel on a device.

proc enqueueNativeKernel*(
  commandQueue: CommandQueue; userFunc: proc (a1: pointer) {.gcSafe.};
  args: pointer; cbArgs: csize_t; numMemObjects: Uint;
  memList: ptr UncheckedArray[Mem]; argsMemLoc: ptr UncheckedArray[ptr Mem];
  numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
  event: ptr Event): ErrorCode
    {.climport.}
      ## Enqueues a command to execute a native C/C++ function not compiled
      ## using the OpenCL compiler.

when ApiVersion >= opencl1_2:
  proc enqueueMarkerWithWaitList*(
    commandQueue: CommandQueue; numEventsInWaitList: Uint;
    eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a marker command which waits for either a list of events
        ## to complete, or all previously enqueued commands to complete.

  proc enqueueBarrierWithWaitList*(
    commandQueue: CommandQueue; numEventsInWaitList: Uint;
    eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## A synchronization point that enqueues a barrier operation.

when ApiVersion >= opencl2_0:
  proc enqueueSVMFree*[T](
    commandQueue: CommandQueue; numSvmPointers: Uint;
    svmPointers: ptr UncheckedArray[SvmPointer];
    pfnFreeFunc: proc (queue: CommandQueue; numSvmPointers: Uint;
                       svmPointers: ptr UncheckedArray[SvmPointer];
                       userData: ptr T);
    userData: ptr T; numEventsInWaitList: Uint;
    eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command to free shared virtual memory allocated using
        ## the `svmAlloc proc <#svmAlloc>`_ or a shared system memory pointer.


  proc enqueueSVMMemcpy*(
    commandQueue: CommandQueue; blockingCopy: Bool;
    dstPtr: pointer|SvmPointer; srcPtr: pointer|SvmPointer; size: csize_t;
    numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command to do a memcpy operation.

  proc enqueueSVMMemFill*[T: ScalarTypes|VectorTypes](
    commandQueue: CommandQueue; svmPtr: SvmPointer;
    pattern: ptr T; patternSize = csize_t(sizeOf(T)); size: csize_t;
    numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command to fill a region in memory with a pattern
        ## of a given pattern size.

  proc enqueueSVMMap*(
    commandQueue: CommandQueue; blockingMap: Bool; flags: set[MapFlag];
    svmPtr: SvmPointer; size: csize_t;
    numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command that will allow the host to update a
        ## region of a SVM buffer

  proc enqueueSVMUnmap*(
    commandQueue: CommandQueue; svmPtr: SvmPointer;
    numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command to indicate that the host has completed
        ## updating the region given by an SVM pointer and which was
        ## specified in a previous call to clEnqueueSVMMap.

when ApiVersion >= opencl2_1:
  proc enqueueSVMMigrateMem*(
    commandQueue: CommandQueue; numSvmPointers: Uint;
    svmPointers: ptr UncheckedArray[SvmPointer];
    sizes: ptr UncheckedArray[csize_t]; flags: set[MemMigrationFlag];
    numEventsInWaitList: Uint; eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command to indicate which device a set of ranges of
        ## SVM allocations should be associated with.



when ApiVersion >= opencl1_2:
  proc getExtensionFunctionAddressForPlatform*(
    platform: PlatformId; funcName: cstring): pointer
      {.climport.}
        ##  Extension function access
        ##
        ##  Returns the extension function address for the given function name,
        ##  or NULL if a valid function can not be found.  The client must
        ##  check to make sure the address is not NULL, before using or
        ##  calling the returned function address.
        ##


when UseDeprecatedOpenCl1_0Apis:
  proc setCommandQueueProperty*(
    commandQueue: CommandQueue; properties: set[CommandQueueProperty];
    enable: Bool;
    oldProperties: ptr set[CommandQueueProperty]): ErrorCode
      {.climport,
       deprecated: "Use of this API is not advised - Use at your own risk".}
        ## Enable or disable properties of a command-queue.
        ##
        ## **WARNING:**
        ##   This API introduces mutable state into the OpenCL implementation.
        ##   It has been REMOVED to better facilitate thread safety.
        ##   The 1.0 API is not thread safe. It is not tested by the
        ##   OpenCL 1.1 conformance test, and consequently may not work or
        ##   may not work dependably.
        ##   It is likely to be non-performant.
        ##   Use of this API is not advised. Use at your own risk.
        ##
        ##   Software developers previously relying on this API are instructed
        ##   to set the command queue
        ##   properties when creating the queue, instead.

#  Deprecated OpenCL 1.1 APIs
when UseDeprecatedOpenCl1_1Apis:
  proc createImage2D*[T](
    context: Context; flags: set[MemFlag]; imageFormat {.byRef.}: ImageFormat;
    imageWidth, imageHeight, imageRowPitch: csize_t; hostPtr: ptr T | pointer;
    errcodeRet: ptr ErrorCode): Mem
      {.climport.}
        ## Creates a 2D image.

  proc createImage3D*[T](
    context: Context; flags: set[MemFlag]; imageFormat {.byRef.}: ImageFormat;
    imageWidth, imageHeight, imageDepth, imageRowPitch, imageSlicePitch: csize_t;
    hostPtr: ptr T | pointer; errcodeRet: ptr ErrorCode): Mem
      {.climport.}
        ## Creates a 3D image.

  proc enqueueMarker*(
    commandQueue: CommandQueue; event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a marker command which waits for all previously
        ## enqueued commands to complete.

  proc enqueueWaitForEvents*(
    commandQueue: CommandQueue; numEvents: Uint;
    eventList: ptr UncheckedArray[Event]): ErrorCode
      {.climport.}
        ## Enqueues a wait on a list of events to complete.

  proc enqueueBarrier*(commandQueue: CommandQueue): ErrorCode
    {.climport.}
      ## A synchronization point that enqueues a barrier operation.

  proc unloadCompiler*(): ErrorCode {.climport.}
    ## Allows the implementation to release the resources allocated by the
    ## OpenCL compiler.

  proc getExtensionFunctionAddress*(funcName: cstring): pointer
    {.climport.}

#  Deprecated OpenCL 2.0 APIs
when UseDeprecatedOpenCl1_2Apis:
  proc createCommandQueue*(
    context: Context; device: DeviceId; properties: set[CommandQueueProperty];
    errcodeRet: ptr ErrorCode): CommandQueue
      {.climport.}
        ## Create a host command-queue on a specific device.

  proc createSampler*(
    context: Context; normalizedCoords: Bool; addressingMode: AddressingMode;
    filterMode: FilterMode;
    errcodeRet: ptr ErrorCode): Sampler
      {.climport.}
        ## Creates a sampler object.

  proc enqueueTask*(
    commandQueue: CommandQueue; kernel: Kernel; numEventsInWaitList: Uint;
    eventWaitList: ptr UncheckedArray[Event];
    event: ptr Event): ErrorCode
      {.climport.}
        ## Enqueues a command to execute a kernel, using a
        ## single work-item, on a device.
